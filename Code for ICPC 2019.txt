  Data Structure, Algorithm & Graph Theory For ICPC 2019
  Author: Ramprosad Gharami
  Department of CSE
  BSMRSTU

**************************************************************

// C++ Template

#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

#define ll                 long long
#define LL                 long long
#define pii                pair<int, int>
#define pll                pair<ll, ll>
#define pil                pair<int, ll>
#define pli                pair<ll, int>
#define vi                 vector<int>
#define vl                 vector<ll>
#define vii                vector<pii>
#define vll                vector<pll>
#define vil                vector<pil>
#define vli                vector<pli>
#define pb                 push_back
#define mp                 make_pair
#define ff                 first
#define ss                 second
#define sz(x)              (int)x.size()
#define TN                 typename
#define all(v)             v.begin(), v.end()
#define fill(a, b)         memset(a, b, sizeof(a))
#define endl               '\n'
#define Int                in()
#define Long               Lin()
#define policy_set         tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
#define policy_multiset    tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>

template <TN T> T gcd(T a, T b) {return !b ? a : gcd(b, a % b);}
template <TN T> T lcm(T a, T b) {return a * (b / gcd(a, b));}
template <TN T> inline void smin(T &a, T b) {a = a < b ? a : b;}
template <TN T> inline void smax(T &a, T b) {a = a > b ? a : b;}

#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }
void err(istream_iterator<string> it) {cout << endl ;}
template<typename T, typename... Args>
void err(istream_iterator<string> it, T a, Args... args) {
    cerr << *it << " = " << a << ", " ;
    err(++it, args...);
}

inline int in() {int n; scanf("%d", &n); return n;}
inline ll Lin() {ll n; scanf("%lld", &n); return n;}
inline double Din() {double n; scanf("%lf", &n); return n;}

const int mod        = (int)1e9 + 7;
const ll  Mod        = (ll)1e9 + 7;

inline int add(int a, int b) {a += b; return a >= mod ? a - mod : a;}
inline int sub(int a, int b) {a -= b; return a < 0 ? a + mod : a;}
inline int mul(int a, int b) {return (ll)a * b % mod;}

const int inf        = (int)2e9 + 5;
const ll  Inf        = (ll)1e18 + 5;
const int N          = 2e5 + 5;



int solve() {
    
    return 0;
}

int main() {
    //ios_base::sync_with_stdio(false); cin.tie(NULL);
    int test = 1, tc = 0;
    //scanf("%d", &test);
    //cin >> test;
    while (test--) {
        //printf("Case %d: ", ++tc);
        solve();
    }
    return 0;
}

***************************************************************

// Mathematics, Number Theory & Combinatorics

// Different Types of Number

struct Different_Types_of_Number {

	vl derangement(int n) {
		vl dr(n + 1, 0);
		dr[0] = 1;
		dr[1] = 0;
		for (int i = 2; i <= n; i++) {
			dr[i] = (dr[i - 1] + dr[i - 2]) * (i - 1);
		}
		return dr;
	}

	vl catalan(int n) {
		vl cat(n + 1, 0);
		cat[0] = 1;
		for (int i = 1; i <= n; i++) {
			cat[i] = (cat[i - 1] * (4 * i - 2)) / (i + 1);
		}
		return cat;
	}

	vector<vl> binomial(int n, int r) {
		vector<vl> ncr(n + 1, vl(r + 1, 0));
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= r; j++) {
				if (j > i) ncr[i][j] = 0;
				else if (i == j || j == 0) ncr[i][j] = 1;
				else ncr[i][j] = ncr[i - 1][j - 1] + ncr[i - 1][j];
			}
		}
		return ncr;
	}
};

// Segmented Sieve(Prime)

struct Segmented_Sieve {

	vi sieve(int n) {
		std::vector<int> prime;
		std::vector<bool> vis(n + 1, false);
		vis[2] = true;
		for (int i = 3; i <= n; i += 2) {
			vis[i] = true;
		}
		for (int i = 3; i * i <= n; i += 2) {
			if (vis[i]) {
				for (int j = i * i; j <= n; j += i + i) {
					vis[j] = false;
				}
			}
		}
		prime.push_back(2);
		for (int i = 3; i <= n; i += 2) {
			if (vis[i]) prime.push_back(i);
		}
		return prime;
	}

	vl seg_sieve(ll l, ll r) {
		std::vector<ll> prime;
		std::vector<bool> vis(r - l + 1, true);
		int n = (int)sqrt(0.5 + r);
		vi p = sieve(n);
		for (int i = 0; i < sz(p) && 1LL * p[i] * p[i] <= r; i++) {
			for (ll x = ((l - 1) / p[i] + 1) * p[i]; x <= r; x += p[i]) {
				if(x == p[i]) continue;
				vis[x - l] = false;
			}
		}
		for (ll i = l; i <= r; i++) {
			if (i > 1 && vis[i - l]) prime.push_back(i);
		}
		return prime;
	}
};

// Euler Totient Fumction(Segmented Sieve)

struct Segmented_Sieve_Totient {

	vi sieve(int n) {
		std::vector<int> prime;
		std::vector<bool> vis(n + 1, false);
		vis[2] = true;
		for (int i = 3; i <= n; i += 2) {
			vis[i] = true;
		}
		for (int i = 3; i * i <= n; i += 2) {
			if (vis[i]) {
				for (int j = i * i; j <= n; j += i + i) {
					vis[j] = false;
				}
			}
		}
		prime.push_back(2);
		for (int i = 3; i <= n; i += 2) {
			if (vis[i]) prime.push_back(i);
		}
		return prime;
	}

	vl seg_sieve_totient(ll l, ll r) {
		std::vector<ll> phi(r - l + 1);
		std::vector<ll> num(r - l + 1);
		int n = (int)sqrt(0.5 + r);
		vi p = sieve(n);
		for (ll i = l; i <= r; i++) {
			phi[i - l] = i;
			num[i - l] = i;
		}
		for (int i = 0; i < sz(p) && 1LL * p[i] * p[i] <= r; i++) {
			for (ll x = ((l - 1) / p[i] + 1) * p[i]; x <= r; x += p[i]) {
				ll& cur = num[x - l];
				while (cur % p[i] == 0) {
					cur /= p[i];
				}
				phi[x - l] = phi[x - l] / p[i] * (p[i] - 1);
			}
		}
		for (ll x = l; x <= r; x++) {
			ll& cur = num[x - l];
			if (cur != 1) phi[x - l] = phi[x - l] / cur * (cur - 1);
		}
		return phi;
	}
};

// Extended GCD(Eucledian algo)

int egcd(int a, int b, int &x, int &y) {
	if (b == 0) {
		x = 1, y = 0;
		return a;
	}
	int x1, y1;
	int d = egcd (b, a % b, x1, y1);
	y = x1 - (a / b) * y1;
	x = y1;
	return d;
}

// Matrix Exponentiation (Finding Nth Fibonacci number)

struct Matrix_Exponentiation {
    
    int m;

    Matrix_Exponentiation() {
    	m = 2;
    }

	matrix multiply(matrix A, matrix B) {
		matrix C(m + 1, vi(m + 1, 0));
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= m; j++) {
				for (int k = 1; k <= m; k++) {
					C[i][j] = add(C[i][j], mul(A[i][k], B[k][j]));
				}
			}
		}
		return C;
	}

	matrix pow(matrix A, ll p) {
		if (p == 1) return A;
		matrix X = pow(A, p / 2);
		X = multiply(X, X);
		if (p & 1) X = multiply(X, A);
		return X;
	}

	int get_ans(ll n) {
		if (n < 2) return n;
		vi F1(m + 1);
		F1[1] = 1;
		F1[2] = 1;
		matrix T(m + 1, vi(m + 1));
		T[1][1] = 1, T[1][2] = 1;
		T[2][1] = 1, T[2][2] = 0;
		T = pow(T, n - 1);
		return T[1][1];
	}
};

// Josephus Problem

struct Josephus_Problem {

	int joseph_one(int n, int k) {   // 1 indexed, O(n) complexity
		int res = 0;
		for (int i = 1; i <= n; ++i) {
			res = (res + k) % i;
		}
		return res + 1;
	}

	int joseph_two(int n, int k) {    // 0 indexed, O(klogn) complexity
		if (n == 1) return 0;
		if (k == 1) return n - 1;
		if (k > n) return (joseph_two(n - 1, k) + k) % n;
		int cnt = n / k;
		int res = joseph_two(n - cnt, k);
		res -= n % k;
		if (res < 0) res += n;
		else res += res / (k - 1);
		return res;
	}
};

**************************************************************************

// String Algorithm

// Suffix Array

struct Suffix_Array {

	std::vector<int> p, pn, cn, ra, pre, cnt;
	std::vector<vi> c;

	Suffix_Array() {
		p.resize(N, 0);
		pn.resize(N, 0);
		cn.resize(N, 0);
		ra.resize(N, 0);
		pre.resize(N, 0);
		cnt.resize(N, 0);
		c.resize(18, vi(N, 0));
	}

	void buildSA() {
		n = sz(s);
		for (int i = 0; i < n; i++) {
			cnt[s[i]]++;
		}
		for (int i = 1; i < 300; i++) {
			cnt[i] += cnt[i - 1];
		}
		for (int i = 0; i < n; i++) {
			p[--cnt[s[i]]] = i;
		}
		c[0][p[0]] = 0;
		int r = 1;
		for (int i = 1; i < n; i++) {
			if (s[p[i]] != s[p[i - 1]]) r++;
			c[0][p[i]] = r - 1;
		}
		for (int k = 0; (1 << k) < n; k++) {
			cnt.resize(N, 0);
			for (int i = 0; i < n; i++) {
				pn[i] = p[i] - (1 << k);
				if (pn[i] < 0) pn[i] += n;
				cnt[c[k][pn[i]]]++;
			}
			for (int i = 1; i < n; i++) {
				cnt[i] += cnt[i - 1];
			}
			for (int i = n - 1; i >= 0; i--) {
				p[--cnt[c[k][pn[i]]]] = pn[i];
			}
			cn[p[0]] = 0;
			r = 1;
			for (int i = 1; i < n; i++) {
				pii cur = {c[k][p[i]], c[k][(p[i] + (1 << k)) % n]};
				pii prev = {c[k][p[i - 1]], c[k][(p[i - 1] + (1 << k)) % n]};
				if (cur != prev) r++;
				cn[p[i]] = r - 1;
			}
			for (int i = 0; i < n; i++) {
				c[k + 1][i] = cn[i];
			}
		}
	}

	void kasaiLCP() {
		for (int i = 0; i < n; i++) {
			ra[p[i]] = i;
		}
		int k = 0;
		for (int i = 0; i < n; i++) {
			if (ra[i] == n - 1) {
				k = 0;
				continue;
			}
			int j = p[ra[i] + 1];
			while (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;
			pre[ra[i]] = k;
			if (k > 0) k--;
		}
	}

	int lcp(int x, int y) {
		int ans = 0;
		for (int i = log2(n); i >= 0; i--) {
			if (c[i][x] == c[i][y]) {
				ans += (1 << i);
				x += (1 << i);
				y += (1 << i);
			}
		}
		return ans;
	}
};

// Trie Data Structure(XOR)

void Add(int root, int num) {
	for (int i = 30; i >= 0; i--) {
		int to = (num & (1 << i)) ? 1 : 0;
		if (node[root][to] == -1) node[root][to] = ++state;
		root = node[root][to];
		cnt[root]++;
	}
}
 
void Remove(int root, int num, int idx) {
	int to = (num & (1 << idx)) ? 1 : 0;
	cnt[node[root][to]]--;
	if(idx > 0) Remove(node[root][to], num, idx - 1);
    if(cnt[node[root][to]] == 0) {
    	node[root][to] = -1;
    }
}
 
void Query(int root, int num) {
	for (int i = 30; i >= 0; i--) {
		int need = (k & (1 << i)) ? 1 : 0;
		int has = (num & (1 << i)) ? 1 : 0;
		if (need == 1) {
			if (has == 0) {
				if (node[root][0] != -1) ans += cnt[node[root][0]];
				if (node[root][1] != -1) root = node[root][1];
				else return;
			}
			else {
				if (node[root][1] != -1) ans += cnt[node[root][1]];
				if (node[root][0] != -1) root = node[root][0];
				else return;
			}
		}
		else {
			if (has == 0) {
				if (node[root][0] != -1) root = node[root][0];
				else return;
			}
			else {
				if (node[root][1] != -1) root = node[root][1];
				else return;
			}
		}
	}
}

// Aho Korasick Algo

struct Aho_Korasick_Algo {

    int state;
    std::vector<vi> node;
    std::vector<int> failure, ans;
    std::vector<bitset<M>> out;

    Aho_Korasick_Algo() {
        state = 0;
        node.resize(M * M, vi(26, -1));
        failure.resize(M * M, -1);
        ans.resize(M * M, 0);
        out.resize(M * M, 0);
    }

    void build_aho(int n) {
        for (int i = 0; i < n; i++) {
            int root = 0, len = strlen(pt[i]);
            for (int j = 0; j < len; j++) {
                int to = pt[i][j] - 'a';
                if (node[root][to] == -1) node[root][to] = ++state;
                root = node[root][to];
            }
            out[root].set(i);
        }
        for (int i = 0; i < 26; i++) {
            if (node[0][i] == -1) node[0][i] = 0;
        }
        queue <int> q;
        for (int i = 0; i < 26; i++) {
            if (node[0][i] != -1 && node[0][i] != 0) {
                failure[node[0][i]] = 0;
                q.push(node[0][i]);
            }
        }
        while (!q.empty()) {
            int root = q.front();
            q.pop();
            for (int i = 0; i < 26; i++) {
                if (node[root][i] != -1) {
                    int fail = failure[root];
                    while (node[fail][i] == -1) {
                        fail = failure[fail];
                    }
                    fail = node[fail][i];
                    failure[node[root][i]] = fail;
                    out[node[root][i]] |= out[fail];
                    q.push(node[root][i]);
                }
            }
        }
    }

    int findstate(int root, int to) {
        while ( node[root][to] == -1) {
            root = failure[root];
        }
        return node[root][to];
    }

    vi get_result(int n) {
        ans.resize(n);
        int root = 0, len = strlen(txt);
        for (int i = 0; i < len; i++) {
            int to = txt[i] - 'a';
            root = findstate(root, to);
            if (out[root] == 0) continue;
            for (int j = 0; j < n; j++) {
                if (out[root].test(j)) ans[j]++;
            }
        }
        return ans;
    }
};

// Palindromic Tree

struct Palindromic_Tree {

	int t, state;
	std::vector<vi> node;
	std::vector<int> link, len;

	Palindromic_Tree() {
		t = state = 2;
		node.resize(N, vi(26, 0));
		link.resize(N, 1);
		len.resize(N, 0);
		len[1] = -1;
	}

	void add(int p) {
		while (p - len[t] - 1 < 0 || s[p - len[t] - 1] != s[p]) t = link[t];
		int x = link[t], c = s[p] - 'a';
		while (p - len[x] - 1 < 0 || s[p - len[x] - 1] != s[p]) x = link[x];
		if (!node[t][c]) {
			node[t][c] = ++state;
			len[state] = len[t] + 2;
			link[state] = len[state] == 1 ? 2 : node[x][c];
		}
		t = node[t][c];
	}

	void buildPT() {
		int n = sz(s);
		for (int i = 0; i < n; i++) {
			add(i);
		}
	}

	int get_result() {
		return state - 2;
	}
};

*****************************************************************************

// Dynamic Programming(DP)

// CHT in DP

struct CHT_INC_MAX {
    vl m, b;

    bool bad(int f1, int f2, int f3) {
        return 1.0 * (b[f2] - b[f1]) * (m[f1] - m[f3]) >= 1.0 * (b[f3] - b[f1]) * (m[f1] - m[f2]);
    }

    void add(ll M, ll B) {
        m.pb(M), b.pb(B);
        int sz = (int)m.size();
        while (sz >= 3 && bad(sz - 3, sz - 2, sz - 1)) {
            m.erase(m.end() - 2);
            b.erase(b.end() - 2);
            sz--;
        }
    }

    ll f(int idx, ll X) {
        return m[idx] * X + b[idx];
    }

    ll query(ll X) {
        int low = 0, high = (int) m.size() - 1;
        while (high - low >= 5) {
            int mid1 = (low + low + high) / 3;
            int mid2 = (low + high + high) / 3;
            if (f(mid1, X) <= f(mid2, X)) {
                low = mid1 + 1;
            } else {
                high = mid2 - 1;
            }
        }
        ll res = f(low, X);
        for (int i = low + 1; i <= high; i++) {
            res = max(res, f(i, X));
        }
        return res;
    }
};

// Dynamic CHT

bool tp ;

struct Line{
	mutable ll m, c, p ;
	bool operator<(const Line& u)const{return tp ? p < u.p : m < u.m ;}
	bool operator<(ll u){return p < u ;}
} ;

struct DynamicCHT : multiset< Line > {
	
	ll div(ll a, ll b){
		return a / b - ((a ^ b) < 0 and (a % b)) ;
	}
	bool intersect(iterator x, iterator y){
		if(y == end()){ x -> p = Inf ; return false ;}
		if(x -> m == y -> m)x -> p = x -> m >= y -> m ? Inf : -Inf ;
		else x -> p = div(x -> c - y -> c, y -> m - x -> m) ;
		return x -> p >= y -> p ;
	}
	void add(ll x, ll y){
		auto c = insert({x, y, 0}), b = c++, a = b ;
		while(intersect(b, c))c = erase(c) ;
		if(a != begin() and intersect(--a, b))intersect(a, b = erase(b)) ;
		while((b = a) != begin() and (--a) -> p >= b -> p)
			intersect(a, erase(b)) ;
	}
	ll query(ll x){
		assert(!empty()) ;
		tp = 1 ;
		auto u = *lower_bound({0, 0, x}) ;
		tp = 0 ;
		return u.m * x + u.c ;
	}
} ;

// IOI Alien Trick

struct CHT_DEC_MIN {
    vl m, b, d;
    int ptr;
    CHT_DEC_MAX() {
        ptr = 0;
    }

    bool bad(int f1, int f2, int f3) {
        return 1.0 * (b[f2] - b[f1]) * (m[f1] - m[f3]) >= 1.0 * (b[f3] - b[f1]) * (m[f1] - m[f2]);
    }

    void add(ll M, ll B, ll D) {
        m.pb(M), b.pb(B), d.pb(D);
        int sz = (int)m.size();
        while(sz >= 3 && bad(sz - 3, sz - 2, sz - 1)) {
            m.erase(m.end() - 2);
            b.erase(b.end() - 2);
            d.erase(d.end() - 2);
            sz--;
        }
    }

    ll f(int idx, ll X) {
        return m[idx] * X + b[idx];
    }

    pll query(ll x) {
        if(ptr >= (int)m.size()) ptr = (int)m.size() - 1;
        while(ptr < m.size() - 1 && f(ptr, x) > f(ptr+1, x)) ptr++;
        return {f(ptr, x), d[ptr] + 1};
    }
};

ll a[N], p[N];

pll call(int n, ll C) {
    CHT_DEC_MIN dp;
    dp.add(0LL, 0LL, 0LL);
    pll cur = {inf, inf};
    for(int i = 1; i <= n; i++) {
        cur = dp.query(2 * p[i]);
        cur.ff = cur.ff + p[i] * p[i] + C;
        dp.add(-p[i], cur.ff + p[i] * p[i], cur.ss);
    }
    return cur;
}

ll bs(int n, int k) {
    ll low = 0LL, high = p[n] * p[n];
    ll ans = p[n];

    while(low <= high) {
        ll mid = (low + high) / 2;
        if(call(n, mid).ss <= k) {
            ans = mid;
            high = mid - 1;
        } else low = mid + 1;
    }
    pll x = call(n, ans);
    return x.ff - (ll)k * ans;
}

// LIS

struct Longest_Increasing_Subsequence {

	std::vector<int> dp;
	std::vector<pii> tem;
	std::vector<int> mx;

	Longest_Increasing_Subsequence() {
		dp.resize(N, 1);
	}

	int bs(int x) {
		int low = 0, high = tem.size() - 1, ans = 0;
		while (low <= high) {
			int mid = (low + high) >> 1;
			if (tem[mid].ff < x) ans = mx[mid], low = mid + 1;
			else high = mid - 1;
		}
		return ans;
	}

	void calc(int left, int right) {
		tem.clear(), mx.clear();
		int mid = (left + right) >> 1;
		for (int i = left; i <= mid; i++) {
			tem.pb({a[i], dp[i]});
		}
		sort(all(tem));
		for (int i = 0; i < tem.size(); i++) {
			if (i == 0) mx.pb(tem[i].ss);
			else mx.pb(max(mx.back(), tem[i].ss));
		}
		for (int i = mid + 1; i <= right; i++) {
			dp[i] = max(dp[i], bs(a[i]) + 1);
		}
	}

	void divide(int left, int right) {
		if (left == right) return;
		int mid = (left + right) >> 1;
		divide(left, mid);
		calc(left, right);
		divide(mid + 1, right);
	}

	int get_result(int n) {
		divide(1, n);
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			smax(ans, dp[i]);
		}
		return ans;
	}
};

// LIS 2D(Using BIT)

void compress(int n) {
    vii A, B;
    for (int i = 1; i <= n; i++) {
        A.pb({l[i], i});
        B.pb({r[i], i});
    }
    sort(all(A)), sort(all(B));
    int num_a = 1, num_b = 1;
    for (int i = 0; i < n; i++) {
        if (i > 0 && A[i].ff != A[i - 1].ff) num_a++;
        if (i > 0 && B[i].ff != B[i - 1].ff) num_b++;
        l[A[i].ss] = num_a, r[B[i].ss] = num_b;
    }
}

void update(int n, int x, int val) {
    while (x <= n) {
        tree[x] = max(tree[x], val);
        x += (x & -x);
    }
}

void update2(int n, int x) {
    while (x <= n) {
        tree[x] = 0;
        x += (x & -x);
    }
}

int query(int x) {
    int mx = 0;
    while (x > 0) {
        mx = max(mx, tree[x]);
        x -= (x & -x);
    }
    return mx;
}

int n;
vector<pair<pii, int > > tem, seg;

void calc(int left, int right) {
    int mid = (left + right) >> 1;
    tem.clear(), seg.clear();
    for (int i = left; i <= mid; i++) {
        tem.pb({{l[i], r[i]}, dp[i]});
    }
    sort(all(tem));
    for (int i = mid + 1; i <= right ; i++) {
        seg.pb({{l[i], r[i]}, i});
    }
    sort(all(seg));
    for (int i = 0, j = 0; i < (int)seg.size(); i++) {
        while (j < (int)tem.size() && tem[j].ff.ff < seg[i].ff.ff) {
            update(n, tem[j].ff.ss, tem[j].ss);
            j++;
        }
        dp[seg[i].ss] = max(dp[seg[i].ss], query(seg[i].ff.ss - 1) + 1);
    }
    for (int i = 0; i < tem.size(); i++) {
        update2(n, tem[i].ff.ss);
    }
}

void divide(int left, int right) {
    if (left == right) return;
    int mid = (left + right) >> 1;
    divide(left, mid);
    calc(left, right);
    divide(mid + 1, right);
}

// Bitmask DP

int bitmask(int mask, int n) {
	if (mask == (1 << n) - 1)  return 0;
	if (dp[mask] != -1)  return dp[mask];
	int ans = 1 << 30;
	for (int i = 0; i < n; i++) {
		if (!(mask & (1 << i))) {
			int price = w[i][i];
			for (int j = 0; j < n; j++) {
				if (i != j && (mask & (1 << j)))
					price += w[i][j];
			}
			price += bitmask(mask ^ (1 << i), n);
			ans = min(ans, price);
		}
	}
	return dp[mask] = ans;
}

// Travelling Salesman Problem(Bitmask)

ll tsp(int mask, int at) {
    if (mask == (1 << n) - 1) return (ll)dis[at][0];
    if (dp[mask][at] != -1) return dp[mask][at];
    ll res = inf;
    for (int i = 0; i < n; i++) {
        if (Check(mask, i) == 0) {
            res = min(res, tsp(Set(mask, i), i) + dis[at][i]);
        }
    }
    return dp[mask][at] = res;
}

// Bitmask DP(Reverse)

int bitmask(int mask) {
	if (mask == 0) return 0;
	int& ans = dp[mask];
	if (ans != -1) return ans;
	ans = 0;
	for (int i = mask; i > 0; i = ((i - 1) & mask)) {
		if (pre[i] > 0) continue;
		smin(ans, bitmask(mask ^ i) + pre[i]);
	}
	return ans;
}

*******************************************************************

// Data Structure

// Binary Indexed Tree(Range Update)

struct BIT_RANGE {

    std::vector<ll> pre, sum;
    int n;

    BIT_RANGE() {
        n = N;
        pre.resize(n + 1, 0);
        sum.resize(n + 1, 0);
    }

    void update(vector<ll>& bit, int x, ll val) {
        while (x <= n) {
            bit[x] += val;
            x += (x & -x);
        }
    }

    void update(int l, int r, ll val) {
        update(sum, l, val);
        update(sum, r + 1, -val);
        update(pre, l, val * (l - 1));
        update(pre, r + 1, -val * r);
    }

    ll query(std::vector<ll>& bit, int x) {
        ll ans = 0;
        while (x > 0) {
            ans += bit[x];
            x -= (x & -x);
        }
        return ans;
    }

    ll query(int l, int r) {
        ll ans = 0;
        ans += query(sum, r) * r - query(pre, r);
        ans -= query(sum, l - 1) * (l - 1) - query(pre, l - 1);
        return ans;
    }
};

// Segment tree lazy Propagate(range Update Range query)

struct Seg_tree_lazy_sum {

	std::vector<ll> node, prop;

	Seg_tree_lazy_sum() {
		node.resize(4 * N, 0);
		prop.resize(4 * N, 0);
	}

	void build(int pos, int left, int right) {
		if (left == right) {
			node[pos] = a[left];
			return;
		}
		int mid = (left + right) >> 1;
		build(pos * 2, left, mid);
		build(pos * 2 + 1, mid + 1, right);
		node[pos] = node[pos * 2] + node[pos * 2 + 1];
	}

	void propagate(int pos) {
		node[pos * 2] += prop[pos];
		node[pos * 2 + 1] += prop[pos];
		prop[pos * 2] += prop[pos];
		prop[pos * 2 + 1] += prop[pos];
		prop[pos] = 0;
	}

	void update(int pos, int left, int right, int x, int y, ll val) {
		if (left > y || right < x) return;
		if (left >= x && right <= y) {
			node[pos] += val;
			prop[pos] += val;
			return;
		}
		if (prop[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x, y, val);
		update(pos * 2 + 1, mid + 1, right, x, y, val);
		node[pos] = node[pos * 2] + node[pos * 2 + 1];
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return node[pos];
		if (prop[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		ll m = query(pos * 2, left, mid, x, y);
		ll n = query(pos * 2 + 1, mid + 1, right, x, y);
		return m + n;
	}
};

// Dynamic Segment Tree

struct Dynamic_Seg_tree_sum {

	std::vector<ll> node;
	std::vector<int> l, r;

	Dynamic_Seg_tree_sum() {
		node.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void get_id(int& x) {
		x = sz(node);
		node.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void update(int pos, int left, int right, int x, ll val) {
		if (left == right) {
			node[pos] += val;
			return;
		}
		node[pos] += val;
		int mid = (left + right) >> 1;
		if (x <= mid) {
			if (l[pos] == -1) get_id(l[pos]);
			update(l[pos], left, mid, x, val);
		}
		else {
			if (r[pos] == -1) get_id(r[pos]);
			update(r[pos], mid + 1, right, x, val);
		}
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y)  return node[pos];
		int mid = (left + right) >> 1;
		ll ans = 0;
		if (l[pos] != -1) ans += query(l[pos], left, mid, x, y);
		if (r[pos] != -1) ans += query(r[pos], mid + 1, right, x, y);
		return ans;
	}
};

// Dynamic Segment Tree Lazy Propagate

struct Dynamic_seg_tree_lazy_sum {
	std::vector<ll> node, prop;
	std::vector<int> l, r;

	Dynamic_seg_tree_lazy_sum() {
		node.push_back(0);
		prop.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void get_id(int& x) {
		x = sz(node);
		node.push_back(0);
		prop.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void propagate(int pos, int left, int right) {
		ll val = prop[pos];
		prop[pos] = 0;
		if (l[pos] == -1) get_id(l[pos]);
		if (r[pos] == -1) get_id(r[pos]);
		int mid = (left + right) >> 1;
		node[l[pos]] += val * (mid - left + 1);
		node[r[pos]] += val * (right - mid);
		prop[l[pos]] += val;
		prop[r[pos]] += val;
	}

	void update(int pos, int left, int right, int x, int y, ll val) {
		if(left > y || right < x) return;
		if (left >= x && right <= y) {
			node[pos] += val * (right - left + 1);
			prop[pos] += val;
			return;
		}
		if (prop[pos]) propagate(pos, left, right);
		int mid = (left + right) >> 1;
		if (x <= mid) {
			if (l[pos] == -1) get_id(l[pos]);
			update(l[pos], left, mid, x, y, val);
		}
		if (y > mid) {
			if (r[pos] == -1) get_id(r[pos]);
			update(r[pos], mid + 1, right, x, y, val);
		}
		node[pos] = 0;
		if (l[pos] != -1) node[pos] += node[l[pos]];
		if (r[pos] != -1) node[pos] += node[r[pos]];
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return node[pos];
		if (prop[pos]) propagate(pos, left, right);
		int mid = (left + right) >> 1;
		ll ans = 0;
		if (l[pos] != -1) ans += query(l[pos], left, mid, x, y);
		if (r[pos] != -1) ans += query(r[pos], mid + 1, right, x, y);
		return ans;
	}
};

// Persistent Segment Tree

struct persistent_sum {

	int idx;
	std::vector<ll> node;
	std::vector<int> l, r, root;

	persistent_sum() {
		idx = 1;
		node.resize(4 * N, 0);
		l.resize(4 * N, 0);
		r.resize(4 * N, 0);
		root.resize(4 * N, 0);
	}

	void build(int pos, int left, int right) {
		if (left == right) {
			node[pos] = a[left];
			return;
		}
		int mid = (left + right) >> 1;
		l[pos] = ++idx;
		r[pos] = ++idx;
		build(l[pos], left, mid);
		build(r[pos], mid + 1, right);
		node[pos] = node[l[pos]] + node[r[pos]];
	}

	int update(int pos, int left, int right, int x, ll val) {
		if (left > x || right < x) return pos;
		int id = ++idx;
		if (left == right) {
			node[id] = node[pos] + val;
			return id;
		}
		int mid = (left + right) >> 1;
		l[id] = update(l[pos], left, mid, x, val);
		r[id] = update(r[pos], mid + 1, right, x, val);
		node[id] = node[l[id]] + node[r[id]];
		return id;
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return node[pos];
		int mid = (left + right) >> 1;
		ll m = query(l[pos], left, mid, x, y);
		ll n = query(r[pos], mid + 1, right, x, y);
		return m + n;
	}
};

// Segment Tree Lazy Propagate 2D

struct Seg_tree_lazy_sum_two {

	std::vector<vl> node, prop;

	Seg_tree_lazy_sum_two() {
		node.resize(4 * N, vl(4 * N, 0));
		prop.resize(4 * N, vl(4 * N, 0));
	}

	void propagate(int pos, int left, int right, int p) {
		int mid = (left + right) >> 1;
		ll val = prop[p][pos];
		prop[p][pos] = 0;
		node[p][pos * 2] += val * (mid - left + 1);
		node[p][pos * 2 + 1] += val * (right - mid);
		prop[p][pos * 2] += val;
		prop[p][pos * 2 + 1] += val;
	}

	void update_init(int pos, int left, int right, int y1, int y2, ll val, int p) {
		if (left > y2 || right < y1) return;
		if (left >= y1 && right <= y2) {
			node[p][pos] += val * (right - left + 1);
			prop[p][pos] += val;
			return;
		}
		if (prop[p][pos]) propagate(pos, left, right, p);
		int mid = (left + right) >> 1;
		update_init(pos * 2, left, mid, y1, y2, val, p);
		update_init(pos * 2 + 1, mid + 1, right, y1, y2, val, p);
		node[p][pos] = node[p][pos * 2] + node[p][pos * 2 + 1];
	}

	void update_merge(int pos, int left, int right, int y1, int y2, int p) {
		if (left > y2 || right < y1) return;
		if (left >= y1 && right <= y2) {
			node[p][pos] = node[p * 2][pos] + node[p * 2 + 1][pos];
			return;
		}
		if (prop[p][pos]) propagate(pos, left, right, p);
		int mid = (left + right) >> 1;
		update_merge(pos * 2, left, mid, y1, y2, p);
		update_merge(pos * 2 + 1, mid + 1, right, y1, y2, p);
		node[p][pos] = node[p * 2][pos] + node[p * 2 + 1][pos];
	}

	void update(int pos, int left, int right, int x1, int y1, int x2, int y2, ll val) {
		if (left > x2 || right < x1) return;
		if (left >= x1 && right <= x2) {
			update_init(1, 1, n, y1, y2, val * (right - left + 1), pos);
			return;
		}
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x1, y1, x2, y2, val);
		update(pos * 2 + 1, mid + 1, right, x1, y1, x2, y2, val);
		update_merge(1, 1, n, y1, y2, pos);
	}

	ll query_merge(int pos, int left, int right, int y1, int y2, int p) {
		if (left > y2 || right < y1) return 0LL;
		if (left >= y1 && right <= y2) return node[p][pos];
		if (prop[p][pos]) propagate(pos, left, right, p);
		int mid = (left + right) >> 1;
		ll m = query_merge(pos * 2, left, mid, y1, y2, p);
		ll n = query_merge(pos * 2 + 1, mid + 1, right, y1, y2, p);
		return m + n;
	}

	ll query(int pos, int left, int right, int x1, int y1, int x2, int y2) {
		if (left > x2 || right < x1) return 0LL;
		if (left >= x1 && right <= x2) return query_merge(1, 1, n, y1, y2, pos);
		int mid = (left + right) >> 1;
		ll m = query(pos * 2, left, mid, x1, y1, x2, y2);
		ll n = query(pos * 2 + 1, mid + 1, right, x1, y1, x2, y2);
		return m + n;
	}
};

// Kth Number in a Range(persistent Segment Tree)

struct kth_min_range {

    int idx;
    std::vector<int> a, b, c;
    std::vector<int> node, l, r, root;

    kth_min_range() {
        idx = 1;

        a.resize(N);
        b.resize(N);
        c.resize(N);

        node.resize(N * 50);
        l.resize(N * 50);
        r.resize(N * 50);
        root.resize(N * 50);
    }

    void compress(int n) {
        vii tem;
        for (int i = 1; i <= n; i++) {
            tem.pb({a[i], i});
        }
        sort(all(tem));
        int cur = 1;
        for (int i = 0; i < n; i++) {
            if (i > 0 && tem[i].ff != tem[i - 1].ff) cur++;
            b[tem[i].ss] = cur;
        }
        for (int i = 1; i <= n; i++) {
            c[b[i]] = a[i];
        }
    }

    void build(int pos, int left, int right) {
        if (left == right) return;
        int mid = (left + right) >> 1;
        l[pos] = ++idx;
        r[pos] = ++idx;
        build(l[pos], left, mid);
        build(r[pos], mid + 1, right);
    }

    int update(int pos, int left, int right, int x) {
        if (left > x || right < x) return pos;
        int id = ++idx;
        if (left == right) {
            node[id] = node[pos] + 1;
            return id;
        }
        int mid = (left + right) >> 1;
        l[id] = update(l[pos], left, mid, x);
        r[id] = update(r[pos], mid + 1, right, x);
        node[id] = node[l[id]] + node[r[id]];
        return id;
    }

    int query(int pos1, int pos2, int left, int right, int k) {
        if (left == right) return c[left];
        int mid = (left + right) >> 1;
        int cnt = node[l[pos2]] - node[l[pos1]];
        if (cnt >= k) return query(l[pos1], l[pos2], left, mid, k);
        else return query(r[pos1], r[pos2], mid + 1, right, k - cnt);
    }
};

// Kth number In Tree

struct kth_min_tree {

    int idx;
    std::vector<int> a, b, c;
    std::vector<int> node, l, r, root;

    std::vector<int> dep;
    std::vector<bool> vis;
    std::vector<vi> g, par;

    kth_min_tree() {
        idx = 2;
        a.resize(N);
        b.resize(N);
        c.resize(N);

        node.resize(N * 50);
        l.resize(N * 50);
        r.resize(N * 50);
        root.resize(N * 50);

        g.resize(N);
        par.resize(17, vi(N, 1));
        vis.resize(N, false);
        dep.resize(N, 0);
    }

    int compress(int n) {
        vii tem;
        for (int i = 1; i <= n ; i++) {
            tem.pb({a[i], i});
        }
        sort(all(tem));
        int cur = 1;
        for (int i = 0; i < n; i++) {
            if (i > 0 && tem[i].ff != tem[i - 1].ff) cur++;
            b[tem[i].ss] = cur;
            c[b[tem[i].ss]] = a[tem[i].ss];
        }
        return cur;
    }

    void build(int pos, int left, int right) {
        if (left == right) return;
        int mid = (left + right) >> 1;
        l[pos] = idx++;
        r[pos] = idx++;
        build(l[pos], left, mid);
        build(r[pos], mid + 1, right);
    }

    int update(int pos, int left, int right, int x) {
        if (left > x || right < x) return pos;
        int id = idx++;
        if (left == right) {
            node[id] = node[pos] + 1;
            return id;
        }
        int mid = (left + right) >> 1;
        l[id] = update(l[pos], left, mid, x);
        r[id] = update(r[pos], mid + 1, right, x);
        node[id] = node[l[id]] + node[r[id]];
        return id;
    }

    int query(int pos1, int pos2, int pos3, int pos4, int left, int right, int k) {
        if (left == right) return c[left];
        int mid = (left + right) >> 1;
        int cnt = node[l[pos1]] + node[l[pos2]] - node[l[pos3]] - node[l[pos4]];
        if (cnt >= k) return query(l[pos1], l[pos2], l[pos3], l[pos4], left, mid, k);
        else return query(r[pos1], r[pos2], r[pos3], r[pos4], mid + 1, right, k - cnt);
    }

    void add_edge(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    void dfs(int n, int u, int p, int d = 1) {
        vis[u] = true, dep[u] = d;
        root[u] = update(root[p], 1, n, b[u]);
        for (int i = 1; i <= 16; i++) {
            par[i][u] = par[i - 1][par[i - 1][u]];
        }
        for (auto v : g[u]) {
            if (vis[v]) continue;
            par[0][v] = u;
            dfs(n, v, u, d + 1);
        }
    }

    int lca(int u, int v) {
        if (dep[u] < dep[v]) swap(u, v);
        for (int i = 16; i >= 0 && u != v; i--) {
            if (dep[par[i][u]] >= dep[v]) u = par[i][u];
        }
        if (u == v) return u;
        for (int i = 16; i >= 0; i--) {
            if (par[i][u] != par[i][v]) u = par[i][u], v = par[i][v];
        }
        return par[0][u];
    }
};

// Merge Sort Tree

struct Merge_sort_tree {

	std::vector<vi> node;

	Merge_sort_tree() {
		node.resize(4 * N);
	}

	void build(int pos, int left, int right) {
		if (left == right) {
			node[pos].push_back(a[left]);
			return;
		}
		int mid = (left + right) >> 1;
		build(pos * 2, left, mid);
		build(pos * 2 + 1, mid + 1, right);
		merge(all(node[pos * 2]), all(node[pos * 2 + 1]), back_inserter(node[pos]));
	}

	int query(int pos, int left, int right, int x, int y, int p, int q) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return upper_bound(all(node[pos]), q) - lower_bound(all(node[pos]), p);
		int mid = (left + right) >> 1;
		int m = query(pos * 2, left, mid, x, y, p, q);
		int n = query(pos * 2 + 1, mid + 1, right, x, y, p, q);
		return m + n;
	}

	int query_mn(int pos, int left, int right, int x, int y, int p, int q) {
		if (left > y || right < x) return inf;
		if (left >= x && right <= y) {
			int cnt = upper_bound(all(node[pos]), q) - lower_bound(all(node[pos]), p);
			if (!cnt) return inf;
			return *lower_bound(all(node[pos]), p);
		}
		int mid = (left + right) >> 1;
		int m = query_mn(pos * 2, left, mid, x, y, p, q);
		int n = query_mn(pos * 2 + 1, mid + 1, right, x, y, p, q);
		return min(m, n);
	}

	int query_mx(int pos, int left, int right, int x, int y, int p, int q) {
		if (left > y || right < x) return -inf;
		if (left >= x && right <= y) {
			int cnt = upper_bound(all(node[pos]), q) - lower_bound(all(node[pos]), p);
			if (!cnt) return -inf;
			auto it = upper_bound(all(node[pos]), q);
			--it;
			return *it;
		}
		int mid = (left + right) >> 1;
		int m = query_mx(pos * 2, left, mid, x, y, p, q);
		int n = query_mx(pos * 2 + 1, mid + 1, right, x, y, p, q);
		return max(m, n);
	}
};

// MO Algo

int a[N], k;

bool cmp(const pair<pii, int> x, const pair<pii, int> y) {
	if (x.ff.ff / k != y.ff.ss / k) return (x < y);
	return ((x.ff.ff / k) & 1) ? (x.ff.ss < y.ff.ss) : (x.ff.ss > y.ff.ss);
}

struct MO_Algo {

	vector<pair<pii, int> > qry;
	int cur_res;
	std::vector<int> cnt, ans;

	MO_Algo() {
		cur_res = 0;
		cnt.resize(N, 0);
		ans.resize(N, 0);
	}

	void add(int x) {
		cnt[a[x]]++;
		if (cnt[a[x]] == 1) cur_res++;
	}

	void remove(int x) {
		cnt[a[x]]--;
		if (cnt[a[x]] == 0) cur_res--;
	}

	void add(int i, int l, int r) {
		qry.push_back(mp(mp(l, r), i));
	}

	void process(int n, int q) {
		k = sqrt(n);
		sort(all(qry), cmp);
		int cur_l = 1, cur_r = 0;
		for (int i = 0; i < q; i++) {
			int l = qry[i].ff.ff, r = qry[i].ff.ss, id = qry[i].ss;
			while (cur_l > l) add(--cur_l);
			while (cur_r < r) add(++cur_r);
			while (cur_l < l) remove(cur_l++);
			while (cur_r > r) remove(cur_r--);
			ans[id] = cur_res;
		}
	}
};

// MO Algo With Update

int a[N], last[N], k;

struct query {
	int l, r, t, id;
	query() {}
	query(int _l, int _r, int _t, int _id) : l(_l), r(_r), t(_t), id(_id) {}
};

bool cmp(const query a, const query b) {
	int l1 = a.l / k, l2 = b.l / k;
	int r1 = a.r / k, r2 = b.r / k;
	if (l1 != l2) return l1 < l2;
	if (r1 != r2) return r1 < r2;
	return a.t < b.t;
}

struct update {
	int x, pre, now;
	update() {}
	update(int _x, int _pre, int _now) : x(_x), pre(_pre), now(_now) {}
};

struct Mo_with_update {

	std::vector<query> qry;
	std::vector<update> upd;
	int cur_res;
	std::vector<int> cnt;
	std::vector<int> ans;

	Mo_with_update() {
		cur_res = 0;
		cnt.resize(N, 0);
		ans.resize(N, 0);
	}

	void add_query(int l, int r, int id) {
		qry.push_back(query(l, r, sz(upd), id));
	}

	void add_update(int x, int y) {
		upd.push_back(update(x, last[x], y));
		last[x] = y;
	}

	void add(int x) {
		x = a[x];
		cnt[x]++;
		if (cnt[x] == 1) cur_res++;
	}

	void remove(int x) {
		x = a[x];
		cnt[x]--;
		if (cnt[x] == 0) cur_res--;
	}

	void apply(int x, int y, int l, int r) {
		if (l <= x && x <= r) {
			remove(x);
			a[x] = y;
			add(x);
		} else {
			a[x] = y;
		}
	}

	void process(int n) {
		k = pow(n, 2.0 / 3);
		int q = sz(qry);
		sort(all(qry), cmp);
		int l = 1, r = 0, t = 0;
		for (int i = 0; i < q; i++) {
			while (t < qry[i].t) t++, apply(upd[t - 1].x, upd[t - 1].now, l, r);
			while (t > qry[i].t) apply(upd[t - 1].x, upd[t - 1].pre, l, r), t--;

			while (l > qry[i].l) add(--l);
			while (r < qry[i].r) add(++r);
			while (l < qry[i].l) remove(l++);
			while (r > qry[i].r) remove(r--);

			ans[qry[i].id] = cur_res;
		}
	}
};

// Minimum Element in Stack

struct minimum_stack {
	
	stack < pair<int, int> > st;

	minimum_stack() {
		while (!st.empty()) {
			st.pop();
		}
	}

	void add(int new_elem) {
		int new_min = st.empty() ? new_elem : min(new_elem, st.top().second);
		st.push({new_elem, new_min});
	}

	void remove() {
		st.pop();
	}

	int get_ans() {
		return st.top().ss;
	}
};

// Minimum Element in queue

struct minimum_queue {

	deque<pair<int, int>> q;
	int cnt_added;
	int cnt_removed;

	minimum_queue() {
		q.clear();
		cnt_added = 0;
		cnt_removed = 0;
	}

	void add(int new_element) {
		while (!q.empty() && q.back().first > new_element) {
			q.pop_back();
		}
		q.push_back({new_element, cnt_added});
		cnt_added++;
	}

	void remove() {
		if (!q.empty() && q.front().second == cnt_removed) {
			q.pop_front();
		}
		cnt_removed++;
	}

	int get_ans() {
		return q.front().ff;
	}
};

******************************************************************

// Graph Theory

// Centroid Decomposition

struct Centroid_decompose {

	int nd;
	ll ans;
	std::vector<vi> g;
	std::vector<int> dis, sz;
	std::vector<bool> vis;

	Centroid_decompose() {
		nd = 0, ans = 0;
		g.resize(N);
		dis.resize(502, 0);
		sz.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void upd_dis(int u, int p, int d) {
		if (d > k)  return;
		dis[d]++;
		for (auto v : g[u]) {
			if (v != p && !vis[v]) upd_dis(v, u, d + 1);
		}
	}

	void upd_res(int u, int p, int d) {
		if (d > k)  return;
		ans += dis[k - d];
		for (auto v : g[u]) {
			if (v != p && !vis[v]) upd_res(v, u, d + 1);
		}
	}

	void getsz(int u, int p = -1) {
		sz[u] = 1, nd++;
		for (auto v : g[u]) {
			if (v != p && !vis[v]) getsz(v, u), sz[u] += sz[v];
		}
	}

	int centroid(int u, int p = -1) {
		for (auto v : g[u]) {
			if (v != p && !vis[v] && sz[v] > nd / 2) return centroid(v, u);
		}
		return u;
	}

	void decompose(int u, int p = -1) {
		dis.resize(502, 0);
		nd = 0, dis[0]++;
		getsz(u);
		int center = centroid(u);
		vis[center] = true;
		for (auto v : g[center]) {
			if (!vis[v]) {
				upd_res(v, center, 1);
				upd_dis(v, center, 1);
			}
		}
		for (auto v : g[center]) {
			if (!vis[v]) decompose(v, center);
		}
	}

	ll get_result(int u) {
        decompose(u);
		return ans;
	}
};

// Diameter of a tree

struct Diameter {

	std::vector<vi> g;
	std::vector<int> mh, dm;

	Diameter() {
		g.resize(N);
		dm.resize(N, 0);
		mh.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void dfs(int u, int p = -1) {
		int mx_height = 0, second_mx_height = 0;
		for (auto v : g[u]) {
			if (p == v) continue;
			dfs(v, u);
			dm[u] = max(dm[u], dm[v]);
			mh[u] = max(mh[u], mh[v] + 1);
			smax(second_mx_height, mh[v] + 1);
			if (second_mx_height > mx_height) swap(mx_height, second_mx_height);
		}
		dm[u] = max(dm[u], mx_height + second_mx_height);
	}
};

// Euler Tour

struct Euler_tour {

	int t;
	std::vector<vi> g, par;
	std::vector<int> st, et, dep;
	std::vector<ll> node;

	Euler_tour() {
		t = 0;
		g.resize(N);
		par.resize(18, vi(N, 1));
		st.resize(N, 0);
		et.resize(N, 0);
		dep.resize(N, 0);
		node.resize(4 * N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void propagate(int pos) {
		node[pos * 2] += node[pos];
		node[pos * 2 + 1] += node[pos];
		node[pos] = 0;
	}

	void update(int pos, int left, int right, int x, int y, int val) {
		if (left > y || right < x) return;
		if (left >= x && right <= y) {
			node[pos] += val;
			return;
		}
		if (node[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x, y, val);
		update(pos * 2 + 1, mid + 1, right, x, y, val);
	}

	int query(int pos, int left, int right, int x) {
		if (left > x || right < x) return 0;
		if (left == right) return node[pos];
		if (node[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		int m = query(pos * 2, left, mid, x);
		int n = query(pos * 2 + 1, mid + 1, right, x);
		return m + n;
	}

	void dfs(int u, int p = -1, int d = 0) {
		st[u] = ++t;
		dep[u] = d;
		for (int i = 1; i <= 17; i++) {
			par[i][u] = par[i - 1][par[i - 1][u]];
		}
		for (int v : g[u]) {
			if (p == v) continue;
			par[0][v] = u;
			dfs(v, u, d + 1);
		}
		et[u] = t;
	}

	int lca(int u, int v) {
		if (dep[u] < dep[v]) swap(u, v);
		for (int i = 17; i >= 0 && u != v; i--) {
			if (dep[par[i][u]] >= dep[v]) u = par[i][u];
		}
		if (u == v) return u;
		for (int i = 17; i >= 0; i--) {
			if (par[i][u] != par[i][v]) u = par[i][u], v = par[i][v];
		}
		return par[0][u];
	}

	ll get_result(int u, int v, int n) {
		int l = lca(u, v);
		ll ans = 0;
		ans += query(1, 1, n, st[u]);
		ans += query(1, 1, n, st[v]);
		ans -= 2 * query(1, 1, n, st[l]);
		return ans + a[l];
	}
};

// Kuhn Algo(maximum bipartite matching)

struct Kuhn_Algo {

	int t;
	std::vector<vi> g;
	std::vector<int> num, p, vis;

	Kuhn_Algo() {
		t = 1;
		g.resize(N);
		num.resize(N, 0);
		p.resize(N, 0);
		vis.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	bool kuhn(int u) {
		if (vis[u] == t) return false;
		vis[u] = t;
		for (auto v : g[u]) {
			if (p[v] == 0 || kuhn(p[v])) {
				p[v] = u;
				return true;
			}
		}
		return false;
	}

	int get_result(int n) {
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			if (kuhn(i)) ans++, t++;
		}
		return ans;
	}
};

// Max Flow (Dinic Algo)

struct Max_Flow_Dinic {

	std::vector<vi> g;
	std::vector<vl> cf;
	std::vector<int> dis, idx;
	std::vector<bool> vis;

	Max_Flow_Dinic() {
		g.resize(N);
		cf.resize(N, vl(N, 0));
		dis.resize(N, -1);
		idx.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v, ll w) {
		g[u].push_back(v);
		g[v].push_back(u);
		cf[u][v] = w;
	}

	bool bfs() {
		queue<int>q;
		q.push(s);
		dis.resize(N, -1);
		dis[s] = 0;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			for (auto v : g[u]) {
				if (dis[v] == -1 && cf[u][v] > 0) {
					dis[v] = dis[u] + 1;
					q.push(v);
				}
			}
		}
		return (dis[t] != -1);
	}

	ll dfs(int u, ll cap) {
		if (cap == 0) return 0;
		if (u == t) return cap;
		for (int& i = idx[u]; i < g[u].size(); i++) {
			int v = g[u][i];
			if (dis[u] + 1 != dis[v] || cf[u][v] < 1) continue;
			ll flow = dfs(v, min(cap, cf[u][v]));
			if (flow == 0) continue;
			cf[u][v] -= flow;
			cf[v][u] += flow;
			return flow;
		}
		return 0;
	}

	ll maximum_flow() {
		ll flow = 0;
		while (1) {
			if (!bfs()) break;
			idx.resize(N, 0);
			while (ll cap = dfs(s, inf)) {
				flow += cap;
			}
		}
		return flow;
	}
};