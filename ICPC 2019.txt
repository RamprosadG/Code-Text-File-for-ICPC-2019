//  Data Structures, Algorithms & Graph Theory For ICPC - 2019
//  Author: Ramprosad Gharami
//  Department of CSE
//  BSMRSTU

************************************************************

// C++ Template

#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

#define ll                 long long
#define LL                 long long
#define pii                pair<int, int>
#define pll                pair<ll, ll>
#define pil                pair<int, ll>
#define pli                pair<ll, int>
#define vi                 vector<int>
#define vl                 vector<ll>
#define vii                vector<pii>
#define vll                vector<pll>
#define vil                vector<pil>
#define vli                vector<pli>
#define pb                 push_back
#define mp                 make_pair
#define ff                 first
#define ss                 second
#define sz(x)              (int)x.size()
#define TN                 typename
#define all(v)             v.begin(), v.end()
#define fill(a, b)         memset(a, b, sizeof(a))
#define endl               '\n'
#define Int                in()
#define Long               Lin()
#define policy_set         tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
#define policy_multiset    tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>

template <TN T> T gcd(T a, T b) {return !b ? a : gcd(b, a % b);}
template <TN T> T lcm(T a, T b) {return a * (b / gcd(a, b));}
template <TN T> inline void smin(T &a, T b) {a = a < b ? a : b;}
template <TN T> inline void smax(T &a, T b) {a = a > b ? a : b;}

#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }
void err(istream_iterator<string> it) {cout << endl ;}
template<typename T, typename... Args>
void err(istream_iterator<string> it, T a, Args... args) {
    cerr << *it << " = " << a << ", " ;
    err(++it, args...);
}

inline int in() {int n; scanf("%d", &n); return n;}
inline ll Lin() {ll n; scanf("%lld", &n); return n;}
inline double Din() {double n; scanf("%lf", &n); return n;}

const int mod        = (int)1e9 + 7;
const ll  Mod        = (ll)1e9 + 7;

inline int add(int a, int b) {a += b; return a >= mod ? a - mod : a;}
inline int sub(int a, int b) {a -= b; return a < 0 ? a + mod : a;}
inline int mul(int a, int b) {return (ll)a * b % mod;}

const int inf        = (int)2e9 + 5;
const ll  Inf        = (ll)1e18 + 5;
const int N          = 2e5 + 5;



int solve() {
    
    return 0;
}

int main() {
    //ios_base::sync_with_stdio(false); cin.tie(NULL);
    int test = 1, tc = 0;
    //scanf("%d", &test);
    //cin >> test;
    while (test--) {
        //printf("Case %d: ", ++tc);
        solve();
    }
    return 0;
}

************************************************************

// Mathematics, Number Theory & Combinatorics

// Bigmod Algorithm

int bigmod(int a, int b) {
	if (b == 0) return 1;
	int x = bigmod(a, b / 2);
	x = mul(x, x);
	if (b & 1) x = mul(x, a);
	return x;
}

// Extended GCD Algorithm

int egcd(int a, int b, int &x, int &y) {
	if (b == 0) {
		x = 1, y = 0;
		return a;
	}
	int x1, y1;
	int d = egcd (b, a % b, x1, y1);
	y = x1 - (a / b) * y1;
	x = y1;
	return d;
}

// Different Types of Special Number

struct Different_Types_of_Number {

	vl factorial(int n) {
		vl fac(n + 1, 0);
		fac[0] = 1;
		fac[1] = 1;
		for (int i = 2; i <= n; i++) {
			fac[i] = fac[i - 1] * i;
		}
		return fac;
	}

	vl fibonacci(int n) {
		vl fib(n + 1, 0);
		fib[0] = 0;
		fib[1] = 1;
		for (int i = 2; i <= n; i++) {
			fib[i] = fib[i - 1] + fib[i - 2];
		}
		return fib;
	}

	vl derangement(int n) {
		vl dr(n + 1, 0);
		dr[0] = 1;
		dr[1] = 0;
		for (int i = 2; i <= n; i++) {
			dr[i] = (dr[i - 1] + dr[i - 2]) * (i - 1);
		}
		return dr;
	}

	vl catalan(int n) {
		vl cat(n + 1, 0);
		cat[0] = 1;
		for (int i = 1; i <= n; i++) {
			cat[i] = (cat[i - 1] * (4 * i - 2)) / (i + 1);
		}
		return cat;
	}

	vector<vl> binomial(int n, int r) {
		vector<vl> ncr(n + 1, vl(r + 1, 0));
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= r; j++) {
				if (j > i) ncr[i][j] = 0;
				else if (i == j || j == 0) ncr[i][j] = 1;
				else ncr[i][j] = ncr[i - 1][j - 1] + ncr[i - 1][j];
			}
		}
		return ncr;
	}
};

// Divisors

struct Divisor {

	int number_of_divisor(ll n) {
		int ans = 1;
		for (int i = 2; 1LL * i * i <= n; i++) {
			if (n % i == 0) {
				int p = 0;
				while (n % i == 0) {
					p++, n /= i;
				}
				ans *= (p + 1);
			}
		}
		if (n != 1) ans *= 2;
		return ans;
	}

	ll sum_of_divisor(ll n) {
		ll ans = 1;
		for (int i = 2; 1LL * i * i <= n; i++) {
			if (n % i == 0) {
				ll p = i;
				while (n % i == 0) {
					p *= i, n /= i;
				}
				ans *= ((p - 1) / (i - 1));
			}
		}
		if (n != 1) ans *= (n + 1);
		return ans;
	}

	vl get_divisor(ll n) {
		std::vector<ll> divisor;
		for(ll i = 1; i * i <= n; i++) {
			if(n % i == 0) {
				divisor.push_back(i);
				if(i != n / i) divisor.push_back(n / i);
			}
		}
		return divisor;
	}

	vector<vi> divisor_sieve(int n) {
		std::vector<vi> divisor(n + 1);
		for (int i = 1; i <= n; i++) {
			for (int j = i; j <= n; j += i) {
				divisor[j].push_back(i);
			}
		}
		return divisor;
	}
};

// Sieve (Prime)

vi sieve(int n) {
	std::vector<int> prime;
	std::vector<bool> vis(n + 1, false);
	vis[2] = true;
	for (int i = 3; i <= n; i += 2) {
		vis[i] = true;
	}
	for (int i = 3; i * i <= n; i += 2) {
		if (vis[i]) {
			for (int j = i * i; j <= n; j += i + i) {
				vis[j] = false;
			}
		}
	}
	prime.push_back(2);
	for (int i = 3; i <= n; i += 2) {
		if (vis[i]) prime.push_back(i);
	}
	return prime;
}

// Bitwise Sieve (Prime)

struct Bitwise_Sieve {

	std::vector<int> vis;
	std::vector<int> prime;

	Bitwise_Sieve() {
		vis.resize(N / 32 + 2, 0);
	}

	vi bitwise_sieve(int n) {
		for (int i = 3; i * i <= n; i += 2) {
			if (!(vis[i / 32] & (1 << (i % 32)))) {
				for (int j = i * i; j <= n; j += i + i) {
					vis[j / 32] |= (1 << (j % 32));
				}
			}
		}
		prime.push_back(2);
		for (int i = 3; i <= n; i += 2) {
			if (!(vis[i / 32] & (1 << (i % 32)))) prime.push_back(i);
		}
		return prime;
	}
};

// Segmented Sieve (Prime)

struct Segmented_Sieve {

	vi sieve(int n) {
		std::vector<int> prime;
		std::vector<bool> vis(n + 1, false);
		vis[2] = true;
		for (int i = 3; i <= n; i += 2) {
			vis[i] = true;
		}
		for (int i = 3; i * i <= n; i += 2) {
			if (vis[i]) {
				for (int j = i * i; j <= n; j += i + i) {
					vis[j] = false;
				}
			}
		}
		prime.push_back(2);
		for (int i = 3; i <= n; i += 2) {
			if (vis[i]) prime.push_back(i);
		}
		return prime;
	}

	vl seg_sieve(ll l, ll r) {
		std::vector<ll> prime;
		std::vector<bool> vis(r - l + 1, true);
		int n = (int)sqrt(0.5 + r);
		vi p = sieve(n);
		for (int i = 0; i < sz(p) && 1LL * p[i] * p[i] <= r; i++) {
			for (ll x = ((l - 1) / p[i] + 1) * p[i]; x <= r; x += p[i]) {
				if(x == p[i]) continue;
				vis[x - l] = false;
			}
		}
		for (ll i = l; i <= r; i++) {
			if (i > 1 && vis[i - l]) prime.push_back(i);
		}
		return prime;
	}
};

// Euler Totient

ll totient(ll n) {
	ll ans = n;
	for(ll i = 2; i * i <= n; i++) {
		if(n % i == 0) {
			while(n % i == 0) n /= i;
			ans = ans / i * (i - 1);
		}
	}
	if(n != 1) ans = ans / n * (n - 1);
	return ans;
}

// Sieve (Euler Totient)

struct Sieve_Euler_Totient {

	std::vector<int> phi;
	std::vector<bool> vis;

	Sieve_Euler_Totient() {
		vis.resize(N, true);
	}

	vi totient(int n) {
		phi.resize(n + 1, 0);
		for (int i = 1; i <= n; i++) {
			phi[i] = i;
		}
		for (int i = 2; i <= n; i++) {
			if (vis[i]) {
				for (int j = i; j <= n; j += i) {
					vis[j] = false;
					phi[j] = phi[j] / i * (i - 1);
				}
			}
		}
		return phi;
	}
};

// Segmented Sieve (Euler Totient)

struct Segmented_Sieve_Totient {

	vi sieve(int n) {
		std::vector<int> prime;
		std::vector<bool> vis(n + 1, false);
		vis[2] = true;
		for (int i = 3; i <= n; i += 2) {
			vis[i] = true;
		}
		for (int i = 3; i * i <= n; i += 2) {
			if (vis[i]) {
				for (int j = i * i; j <= n; j += i + i) {
					vis[j] = false;
				}
			}
		}
		prime.push_back(2);
		for (int i = 3; i <= n; i += 2) {
			if (vis[i]) prime.push_back(i);
		}
		return prime;
	}

	vl seg_sieve_totient(ll l, ll r) {
		std::vector<ll> phi(r - l + 1);
		std::vector<ll> num(r - l + 1);
		int n = (int)sqrt(0.5 + r);
		vi p = sieve(n);
		for (ll i = l; i <= r; i++) {
			phi[i - l] = i;
			num[i - l] = i;
		}
		for (int i = 0; i < sz(p) && 1LL * p[i] * p[i] <= r; i++) {
			for (ll x = ((l - 1) / p[i] + 1) * p[i]; x <= r; x += p[i]) {
				ll& cur = num[x - l];
				while (cur % p[i] == 0) {
					cur /= p[i];
				}
				phi[x - l] = phi[x - l] / p[i] * (p[i] - 1);
			}
		}
		for (ll x = l; x <= r; x++) {
			ll& cur = num[x - l];
			if (cur != 1) phi[x - l] = phi[x - l] / cur * (cur - 1);
		}
		return phi;
	}
};

// Matrix Exponentiation (Fibonacci number)

struct Matrix_Exponentiation {
    
    int m;

    Matrix_Exponentiation() {
    	m = 2;
    }

	matrix multiply(matrix A, matrix B) {
		matrix C(m + 1, vi(m + 1, 0));
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= m; j++) {
				for (int k = 1; k <= m; k++) {
					C[i][j] = add(C[i][j], mul(A[i][k], B[k][j]));
				}
			}
		}
		return C;
	}

	matrix pow(matrix A, ll p) {
		if (p == 1) return A;
		matrix X = pow(A, p / 2);
		X = multiply(X, X);
		if (p & 1) X = multiply(X, A);
		return X;
	}

	int get_ans(ll n) {
		if (n < 2) return n;
		vi F1(m + 1);
		F1[1] = 1;
		F1[2] = 1;
		matrix T(m + 1, vi(m + 1));
		T[1][1] = 1, T[1][2] = 1;
		T[2][1] = 1, T[2][2] = 0;
		T = pow(T, n - 1);
		return T[1][1];
	}
};

// Josephus Problem

struct Josephus_Problem {

	int joseph_one(int n, int k) {   // 1 indexed, O(n) complexity
		int res = 0;
		for (int i = 1; i <= n; ++i) {
			res = (res + k) % i;
		}
		return res + 1;
	}

	int joseph_two(int n, int k) {    // 0 indexed, O(klogn) complexity
		if (n == 1) return 0;
		if (k == 1) return n - 1;
		if (k > n) return (joseph_two(n - 1, k) + k) % n;
		int cnt = n / k;
		int res = joseph_two(n - cnt, k);
		res -= n % k;
		if (res < 0) res += n;
		else res += res / (k - 1);
		return res;
	}
};

// Linear Diophantine Equation

struct Linear_Diophantine_Equation {

	int egcd(int a, int b, int &x, int &y) {
		if (b == 0) {
			x = 1, y = 0;
			return a;
		}
		int x1, y1;
		int d = egcd (b, a % b, x1, y1);
		y = x1 - (a / b) * y1;
		x = y1;
		return d;
	}

	bool diophantine(int A, int B, int C, int &x, int &y) {
		int g = gcd(A, B);
		if (C % g != 0) return false;
		int a = A / g, b = B / g, c = C / g;
		egcd(a, b, x, y);
		if (g < 0) a *= -1; b *= -1; c *= -1;
		x *= c; y *= c;
		return true;
	}
};

// Trailing Zero & Number of Digits

struct Trailing_Zero_Number_of_Digit {

	ll calc(ll n, int base, int p) {
		int cnt = 0;
		while (base % p == 0) cnt++, base /= p;
		ll cur = 0;
		while (n) {
			n /= p;
			cur += n;
		}
		cur /= cnt;
		return cur;
	}

	ll trailing_zero(ll n, int base) {
		int tem = base;
		ll ans = Inf;
		for (int i = 2; i * i <= base; i++) {
			if (tem % i == 0) {
				while (tem % i == 0) tem /= i;
				smin(ans, calc(n, base, i));
			}
		}
		if (tem > 1) smin(ans, calc(n, tem, tem));
		return ans;
	}

	int Number_of_Digit(int n, int base) {
		double ans = 1.0;
		for (int i = 1; i <= n; i++) {
			ans += log10(1.0 * n) / log10(1.0 * base);
		}
		return ans;
	}
};

************************************************************

// String Algorithms

// Hashing Data Structure

struct Hash_Value {
	unsigned long long prime;
	std::vector<unsigned long long> h, p;

	Hash_Value() {
		prime = 97;
		h.resize(N, 0);
		p.resize(N, 1);
	}

	void hashing(string s) {
		int n = sz(s);
		for (int i = 1; i <= n; i++) {
			p[i] = p[i - 1] * prime;
			h[i] = h[i - 1] * prime + (s[i - 1] - 'a' + 1);
		}
	}

	unsigned long long get_hash(int a, int b) {
		return h[b] -  h[a - 1] * p[b - a + 1];
	}
};

// Trie Data Structure

struct Trie_data_Structure {

	std::vector<vi> node;
	std::vector<int> cnt;
	std::vector<int> num;
	int state;

	Trie_data_Structure() {
		state = 0;
		node.resize(N, vi(26, -1));
		cnt.resize(N, 0);
		num.resize(N, 0);
	}

	void Add(int root, string s) {
		int n = sz(s);
		for (int i = 0; i < n; i++) {
			int to = s[i] - 'a';
			if (node[root][to] == -1) node[root][to] = ++state;
			root = node[root][to];
			num[root]++;
		}
		cnt[root]++;
	}

	void Remove(int root, string s, int pos = 0) {
		int to = s[pos] - 'a';
		int n = sz(s) - 1;
		num[node[root][to]]--;
		if (n == pos) cnt[node[root][to]]--;
		else Remove(node[root][to], s, pos + 1);
		if (num[node[root][to]] == 0) {
			node[root][to] = -1;
		}
	}

	int Search(int root, string s) {
		int n = sz(s);
		for (int i = 0; i < n; i++) {
			int to = s[i] - 'a';
			if (node[root][to] == -1) return 0;
			root = node[root][to];
		}
		return cnt[root];
	}
};

// Trie Data Structure (Finding Subarray Whose XOR is minimum, Maximum)

struct trie {
    trie *node[2];
    trie() {
        node[0] = node[1] = NULL;
    }
};

void Insert(trie* root, int x) {
    for (int i = 31; i >= 0; i--) {
        int to = (x & (1 << i)) ? 1 : 0;
        if (root->node[to] == NULL) root->node[to] = new trie;
        root = root->node[to];
    }
}

int max_query(trie* root, int x) {
    int ans = 0;
    for (int i = 31; i >= 0; i--) {
        int to = (x & (1 << i)) ? 1 : 0;
        if (root->node[to ^ 1]) {
            ans += (1 << i);
            root = root->node[to ^ 1];
        } else
            root = root->node[to];
    }
    return ans;
}

int min_query(trie* root, int x) {
    int ans = 0;
    for (int i = 31; i >= 0; i--) {
        int to = (x & (1 << i)) ? 1 : 0;
        if (root->node[to])
            root = root->node[to];
        else {
            ans += (1 << i);
            root = root->node[to ^ 1];
        }
    }
    return ans;
}

void del(trie* root) {
    for (int i = 0; i < 2; i++) {
        if (root->node[i])
            del(root->node[i]);
    }
    delete root;
}

int main() {
        trie* root = new trie;
        Insert(root, 0);
        int n = in(), mx = 0, mn = INT_MAX, p = 0;
        for (int i = 1; i <= n; i++) {
            int a = in();
            p ^= a;
            smax(mx, max_query(root, p));
            smin(mn, min_query(root, p));
            Insert(root, p);
        }
        printf("%d %d\n", mx, mn);
        del(root);
    return 0;
}

// Trie Data Structure (Number of Subarray which XOR is less Than K)

int k;
int node[N][2], cnt[N];

void Add(int root, int num) {
	for (int i = 30; i >= 0; i--) {
		int to = (num & (1 << i)) ? 1 : 0;
		if (node[root][to] == -1) node[root][to] = ++state;
		root = node[root][to];
		cnt[root]++;
	}
}
 
void Remove(int root, int num, int idx) {
	int to = (num & (1 << idx)) ? 1 : 0;
	cnt[node[root][to]]--;
	if(idx > 0) Remove(node[root][to], num, idx - 1);
    if(cnt[node[root][to]] == 0) {
    	node[root][to] = -1;
    }
}
 
void Query(int root, int num) {
	for (int i = 30; i >= 0; i--) {
		int need = (k & (1 << i)) ? 1 : 0;
		int has = (num & (1 << i)) ? 1 : 0;
		if (need == 1) {
			if (has == 0) {
				if (node[root][0] != -1) ans += cnt[node[root][0]];
				if (node[root][1] != -1) root = node[root][1];
				else return;
			}
			else {
				if (node[root][1] != -1) ans += cnt[node[root][1]];
				if (node[root][0] != -1) root = node[root][0];
				else return;
			}
		}
		else {
			if (has == 0) {
				if (node[root][0] != -1) root = node[root][0];
				else return;
			}
			else {
				if (node[root][1] != -1) root = node[root][1];
				else return;
			}
		}
	}
}

// Knuth Morris Pratt (KMP) 

struct Knuth_Morris_Pratt {

    std::vector<int> pi;

    void prefix(string p) {
        int now = -1, n = sz(p);
        pi.push_back(-1);
        for (int i = 1; i < n; i++) {
            while (now != -1 && p[now + 1] != p[i]) {
                now = pi[now];
            }
            if (p[now + 1] == p[i]) pi.push_back(++now);
            else pi.push_back(-1), now = -1;
        }
    }

    int kmp(string t, string p) {
        int now = -1, n = sz(p), m = sz(t), ans = 0;
        for (int i = 0; i < m; i++) {
            while (now != -1 && p[now + 1] != t[i]) {
                now = pi[now];
            }
            if (p[now + 1] == t[i]) ++now;
            else now = -1;
            if (now == n - 1) {
                ans++;
                now = pi[now];
            }
        }
        return ans;
    }
};

// Z Algorithm

struct Z_Algorithm {

	std::vector<int> z;

	vi zfunction(string p) {
		int left = 0, right = 0, n = sz(p);
		z.resize(n, 0);
		for (int i = 1; i < n; i++) {
			if (i <= right) z[i] = min(z[i - left], right - i + 1);
			while (i + z[i] < n && p[i + z[i]] == p[z[i]]) z[i]++;
			if (i + z[i] - 1 > right) left = i, right = i + z[i] - 1;
		}
		return z;
	}
};

// Suffix Array

string s;
int n;

struct Suffix_Array {

	std::vector<int> p, pn, cn, ra, pre, cnt;
	std::vector<vi> c;

	Suffix_Array() {
		p.resize(N, 0);
		pn.resize(N, 0);
		cn.resize(N, 0);
		ra.resize(N, 0);
		pre.resize(N, 0);
		cnt.resize(N, 0);
		c.resize(18, vi(N, 0));
	}

	void buildSA() {
		n = sz(s);
		for (int i = 0; i < n; i++) {
			cnt[s[i]]++;
		}
		for (int i = 1; i < 300; i++) {
			cnt[i] += cnt[i - 1];
		}
		for (int i = 0; i < n; i++) {
			p[--cnt[s[i]]] = i;
		}
		c[0][p[0]] = 0;
		int r = 1;
		for (int i = 1; i < n; i++) {
			if (s[p[i]] != s[p[i - 1]]) r++;
			c[0][p[i]] = r - 1;
		}
		for (int k = 0; (1 << k) < n; k++) {
			cnt.resize(N, 0);
			for (int i = 0; i < n; i++) {
				pn[i] = p[i] - (1 << k);
				if (pn[i] < 0) pn[i] += n;
				cnt[c[k][pn[i]]]++;
			}
			for (int i = 1; i < n; i++) {
				cnt[i] += cnt[i - 1];
			}
			for (int i = n - 1; i >= 0; i--) {
				p[--cnt[c[k][pn[i]]]] = pn[i];
			}
			cn[p[0]] = 0;
			r = 1;
			for (int i = 1; i < n; i++) {
				pii cur = {c[k][p[i]], c[k][(p[i] + (1 << k)) % n]};
				pii prev = {c[k][p[i - 1]], c[k][(p[i - 1] + (1 << k)) % n]};
				if (cur != prev) r++;
				cn[p[i]] = r - 1;
			}
			for (int i = 0; i < n; i++) {
				c[k + 1][i] = cn[i];
			}
		}
	}

	void kasaiLCP() {
		for (int i = 0; i < n; i++) {
			ra[p[i]] = i;
		}
		int k = 0;
		for (int i = 0; i < n; i++) {
			if (ra[i] == n - 1) {
				k = 0;
				continue;
			}
			int j = p[ra[i] + 1];
			while (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;
			pre[ra[i]] = k;
			if (k > 0) k--;
		}
	}

	int lcp(int x, int y) {
		int ans = 0;
		for (int i = log2(n); i >= 0; i--) {
			if (c[i][x] == c[i][y]) {
				ans += (1 << i);
				x += (1 << i);
				y += (1 << i);
			}
		}
		return ans;
	}
};

int solve() {
	cin >> s;
	s += "$";
	Suffix_Array dp;
	dp.buildSA();
	dp.kasaiLCP();
	int q = in();
	while (q--) {
		int x = in(), y = in();
		int ans = dp.lcp(x, y);
		printf("%d\n", ans);
	}
	return 0;
}

// Aho Korasick Algorithm

char pt[M][M], txt[N];

struct Aho_Korasick_Algo {

    int state;
    std::vector<vi> node;
    std::vector<int> failure, ans;
    std::vector<bitset<M>> out;

    Aho_Korasick_Algo() {
        state = 0;
        node.resize(M * M, vi(26, -1));
        failure.resize(M * M, -1);
        ans.resize(M * M, 0);
        out.resize(M * M, 0);
    }

    void build_aho(int n) {
        for (int i = 0; i < n; i++) {
            int root = 0, len = strlen(pt[i]);
            for (int j = 0; j < len; j++) {
                int to = pt[i][j] - 'a';
                if (node[root][to] == -1) node[root][to] = ++state;
                root = node[root][to];
            }
            out[root].set(i);
        }
        for (int i = 0; i < 26; i++) {
            if (node[0][i] == -1) node[0][i] = 0;
        }
        queue <int> q;
        for (int i = 0; i < 26; i++) {
            if (node[0][i] != -1 && node[0][i] != 0) {
                failure[node[0][i]] = 0;
                q.push(node[0][i]);
            }
        }
        while (!q.empty()) {
            int root = q.front();
            q.pop();
            for (int i = 0; i < 26; i++) {
                if (node[root][i] != -1) {
                    int fail = failure[root];
                    while (node[fail][i] == -1) {
                        fail = failure[fail];
                    }
                    fail = node[fail][i];
                    failure[node[root][i]] = fail;
                    out[node[root][i]] |= out[fail];
                    q.push(node[root][i]);
                }
            }
        }
    }

    int findstate(int root, int to) {
        while ( node[root][to] == -1) {
            root = failure[root];
        }
        return node[root][to];
    }

    vi get_result(int n) {
        ans.resize(n);
        int root = 0, len = strlen(txt);
        for (int i = 0; i < len; i++) {
            int to = txt[i] - 'a';
            root = findstate(root, to);
            if (out[root] == 0) continue;
            for (int j = 0; j < n; j++) {
                if (out[root].test(j)) ans[j]++;
            }
        }
        return ans;
    }
};

int solve() {
    Aho_Korasick_Algo dp;
    int n = in();
    scanf("%s", txt);
    for (int i = 0; i < n; i++) {
        scanf("%s", pt[i]);
    }
    dp.build_aho(n);
    vi ans = dp.get_result(n);
    for (int i = 0; i < n; i++) {
        printf("%d\n", ans[i]);
    }
    return 0;
}

// Manachers Algorithm (Palindrome counting)

struct Manachers_Algo {

    std::vector<int> dp1, dp2;

    Manachers_Algo() {
        dp1.resize(N, 0);
        dp2.resize(N, 0);
    }

    void manach(string s) {
        int n = sz(s);
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = i > r ? 1 : min(dp1[l + r - i], r - i);
            while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {
                k++;
            }
            dp1[i] = k--;
            if (i + k > r) l = i - k, r = i + k;
        }
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = i > r ? 0 : min(dp2[l + r - i + 1], r - i);
            while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) {
                k++;
            }
            dp2[i] = k--;
            if (i + k > r) l = i - k - 1, r = i + k;
        }
    }

    ll get_result(string s) {
        manach(s);
        ll ans = 0;
        int n = sz(s);
        for (int i = 0; i < n; i++) {
            ans += dp1[i] + dp2[i];
        }
        return ans;
    }
};

// Palindromic Tree

string s;

struct Palindromic_Tree {

	int t, state;
	std::vector<vi> node;
	std::vector<int> link, len;

	Palindromic_Tree() {
		t = state = 2;
		node.resize(N, vi(26, 0));
		link.resize(N, 1);
		len.resize(N, 0);
		len[1] = -1;
	}

	void add(int p) {
		while (p - len[t] - 1 < 0 || s[p - len[t] - 1] != s[p]) t = link[t];
		int x = link[t], c = s[p] - 'a';
		while (p - len[x] - 1 < 0 || s[p - len[x] - 1] != s[p]) x = link[x];
		if (!node[t][c]) {
			node[t][c] = ++state;
			len[state] = len[t] + 2;
			link[state] = len[state] == 1 ? 2 : node[x][c];
		}
		t = node[t][c];
	}

	void buildPT() {
		int n = sz(s);
		for (int i = 0; i < n; i++) {
			add(i);
		}
	}

	int get_result() {
		return state - 2;
	}
};

*****************************************************************************

// Dynamic Programming (DP)

// 0 - 1 Knapsack

std::vector<ll> val, wt;
std::vector<vl> dp;

ll call(ll w, int n) {
	if (n == 0 || w == 0) return 0LL;
	if (dp[n][w] != -1) return dp[n][w];
	if (w < wt[n]) return dp[n][w] = call(w, n - 1);
	return dp[n][w] = max(call(w, n - 1), val[n] + call(w - wt[n], n - 1));
}

// Digit Dp

int a, b, d, k;
vi num;

int dp[12][12][2];

int digitdP(int pos, int cnt, int f) {
	if (cnt > k) return 0;
	if (pos == num.size()) {
		if (cnt == k) return 1;
		return 0;
	}
	if (dp[pos][cnt][f] != -1) return dp[pos][cnt][f];
	int res = 0, m = 9;
	if (f == 0) m = num[pos];
	for (int dgt = 0; dgt <= m; dgt++) {
		int nf = f, ncnt = cnt;
		if (dgt == d) ncnt++;
		if (f == 0 && dgt < m) nf = 1;
		res += digitdP(pos + 1, ncnt, nf);
	}
	return dp[pos][cnt][f] = res;
}

int call(int n) {
	num.clear();
	while (n) {
		num.pb(n % 10);
		n /= 10;
	}
	reverse(all(num));
	fill(dp, -1);
	return digitdP(0, 0, 0);
}

// Digit Dp (range)

string a, b;
ll dp[20][10][2][2][2], mx[20][10][2][2][2], p[20] = {1LL};
int n;

void digit_dp(int pos, int dgt, int big, int small, int st) {
	ll& ans = dp[pos][dgt][big][small][st];
	ll& pdt = mx[pos][dgt][big][small][st];
	if (ans != -1) return;
	if (pos == n) {
		ans = 1LL * dgt;
		pdt = 1LL * dgt;
		return;
	}
	int l = 0, r = 9;
	if (big == 0) l = a[pos] - '0';
	if (small == 0) r = b[pos] - '0';
	for (int i = l; i <= r; i++) {
		int nbig = big, nsmall = small, nst = st;
		if (i > l) nbig = 1;
		if (i < r) nsmall = 1;
		if (i > 0) nst = 1;
		digit_dp(pos + 1, i, nbig, nsmall, nst);
		ll cur = dp[pos + 1][i][nbig][nsmall][nst];
		if (cur > ans) ans = cur, pdt = mx[pos + 1][i][nbig][nsmall][nst];
	}
	if (st) pdt = p[n - pos] * dgt + pdt, ans *= dgt;
	return;
}

void process() {
	int n = 18;
	for (int i = 1; i <= n; i++) {
		p[i] = p[i - 1] * 10;
	}
}

// Convex Hull Trick (Slope Increasing & Maximum Query)

struct CHT_INC_MAX {
    vl m, b;

    bool bad(int f1, int f2, int f3) {
        return 1.0 * (b[f2] - b[f1]) * (m[f1] - m[f3]) >= 1.0 * (b[f3] - b[f1]) * (m[f1] - m[f2]);
    }

    void add(ll M, ll B) {
        m.pb(M), b.pb(B);
        int sz = (int)m.size();
        while (sz >= 3 && bad(sz - 3, sz - 2, sz - 1)) {
            m.erase(m.end() - 2);
            b.erase(b.end() - 2);
            sz--;
        }
    }

    ll f(int idx, ll X) {
        return m[idx] * X + b[idx];
    }

    ll query(ll X) {
        int low = 0, high = (int) m.size() - 1;
        while (high - low >= 5) {
            int mid1 = (low + low + high) / 3;
            int mid2 = (low + high + high) / 3;
            if (f(mid1, X) <= f(mid2, X)) {
                low = mid1 + 1;
            } else {
                high = mid2 - 1;
            }
        }
        ll res = f(low, X);
        for (int i = low + 1; i <= high; i++) {
            res = max(res, f(i, X));
        }
        return res;
    }
};

int solve() {
    int q = Int;
    CHT_DEC_MIN dp;
        while (q--) {
            int ck = Int;
            if (ck == 1) {
                ll M = Long, B = Long;
                dp.add(M, B);
            } else {
                ll X = Long;
                printf("%lld\n", dp.query(X));
            }
        }
    return 0;
}

// Dynamic Convex Hull Trick

bool tp ;

struct Line{
	mutable ll m, c, p ;
	bool operator<(const Line& u)const{return tp ? p < u.p : m < u.m ;}
	bool operator<(ll u){return p < u ;}
} ;

struct DynamicCHT : multiset< Line > {
	
	ll div(ll a, ll b){
		return a / b - ((a ^ b) < 0 and (a % b)) ;
	}
	bool intersect(iterator x, iterator y){
		if(y == end()){ x -> p = Inf ; return false ;}
		if(x -> m == y -> m)x -> p = x -> m >= y -> m ? Inf : -Inf ;
		else x -> p = div(x -> c - y -> c, y -> m - x -> m) ;
		return x -> p >= y -> p ;
	}
	void add(ll x, ll y){
		auto c = insert({x, y, 0}), b = c++, a = b ;
		while(intersect(b, c))c = erase(c) ;
		if(a != begin() and intersect(--a, b))intersect(a, b = erase(b)) ;
		while((b = a) != begin() and (--a) -> p >= b -> p)
			intersect(a, erase(b)) ;
	}
	ll query(ll x){
		assert(!empty()) ;
		tp = 1 ;
		auto u = *lower_bound({0, 0, x}) ;
		tp = 0 ;
		return u.m * x + u.c ;
	}
} ;

int solve() {
    int q = Int;
    DynamicCHT dp;
        while (q--) {
            int ck = Int;
            if (ck == 1) {
                ll M = Long, B = Long;
                dp.add(M, B);
            } else {
                ll X = Long;
                printf("%lld\n", dp.query(X));
            }
        }
    return 0;
}

// IOI 16 Alien trick in CHT

struct CHT_DEC_MIN {
    vl m, b, d;
    int ptr;
    CHT_DEC_MAX() {
        ptr = 0;
    }

    bool bad(int f1, int f2, int f3) {
        return 1.0 * (b[f2] - b[f1]) * (m[f1] - m[f3]) >= 1.0 * (b[f3] - b[f1]) * (m[f1] - m[f2]);
    }

    void add(ll M, ll B, ll D) {
        m.pb(M), b.pb(B), d.pb(D);
        int sz = (int)m.size();
        while(sz >= 3 && bad(sz - 3, sz - 2, sz - 1)) {
            m.erase(m.end() - 2);
            b.erase(b.end() - 2);
            d.erase(d.end() - 2);
            sz--;
        }
    }

    ll f(int idx, ll X) {
        return m[idx] * X + b[idx];
    }

    pll query(ll x) {
        if(ptr >= (int)m.size()) ptr = (int)m.size() - 1;
        while(ptr < m.size() - 1 && f(ptr, x) > f(ptr+1, x)) ptr++;
        return {f(ptr, x), d[ptr] + 1};
    }
};

ll a[N], p[N];

pll call(int n, ll C) {
    CHT_DEC_MIN dp;
    dp.add(0LL, 0LL, 0LL);
    pll cur = {inf, inf};
    for(int i = 1; i <= n; i++) {
        cur = dp.query(2 * p[i]);
        cur.ff = cur.ff + p[i] * p[i] + C;
        dp.add(-p[i], cur.ff + p[i] * p[i], cur.ss);
    }
    return cur;
}

ll bs(int n, int k) {
    ll low = 0LL, high = p[n] * p[n];
    ll ans = p[n];

    while(low <= high) {
        ll mid = (low + high) / 2;
        if(call(n, mid).ss <= k) {
            ans = mid;
            high = mid - 1;
        } else low = mid + 1;
    }
    pll x = call(n, ans);
    return x.ff - (ll)k * ans;
}

int solve() {
    int n = in(), k = in();
    for(int i = 1; i <= n; i++) {
        a[i] = Lin();
        p[i] = p[i - 1] + a[i];
    }
    printf("%lld\n", bs(n, k));
    return 0;
}

// Longest Common Subsequence (LCS)

string s, t;

struct Longest_Common_Subsequence {

	std::vector<vi> dp;
	std::vector<vii> par;

	Longest_Common_Subsequence() {
		dp.resize(N, vi(N, -1));
		par.resize(N, vii(N, mp(-1, -1)));
	}

	int lcs(int n, int m) {
		if (n == -1 || m == -1) return 0;
		if (dp[n][m] != -1) return dp[n][m];
		if (s[n] == t[m]) {
			par[n][m] = {n - 1, m - 1};
			return dp[n][m] = 1 + lcs(n - 1, m - 1);
		}
		int l = lcs(n, m - 1), u = lcs(n - 1, m);
		if (l > u) {
			par[n][m] = {n, m - 1};
			return dp[n][m] = l;
		}
		else {
			par[n][m] = {n - 1, m};
			return dp[n][m] = u;
		}
	}

	void path(int n, int m) {
		if (n == -1 || m == -1) return;
		path(par[n][m].ff, par[n][m].ss);
		if (s[n] == t[m]) printf("%c", s[n]);
	}
};

// Longest Increasing Subsequence(LIS)

int tree[N];
int a[N];

void compress(int n) {
    vii tem;
    for (int i = 1; i <= n; i++) {
        tem.pb({a[i], i});
    }
    sort(all(tem));
    int cur = 1;
    for (int i = 0; i < n; i++) {
        if (i > 0 && tem[i].ff != tem[i - 1].ff) cur++;
        a[tem[i].ss] = cur;
    }
}

void update(int n, int x, int val) {
    while (x <= n) {
        tree[x] = max(tree[x], val);
        x += (x & -x);
    }
}

int query(int x) {
    int mx = 0;
    while (x > 0) {
        mx = max(mx, tree[x]);
        x -= (x & -x);
    }
    return mx;
}

int solve() {
    int n = in();
    for (int i = 1; i <= n; i++) {
        a[i] = in();
    }
    compress(n);
    for (int i = 1; i <= n; i++) {
        update(n, a[i], query(a[i] - 1) + 1);
    }
    int ans = query(n);
    printf("%d\n", ans);
    return 0;
}

// Longest Increasing Subsequence 2D

int l[N], r[N];
int dp[N];

int tree[N];

void compress(int n) {
    vii A, B;
    for (int i = 1; i <= n; i++) {
        A.pb({l[i], i});
        B.pb({r[i], i});
    }
    sort(all(A)), sort(all(B));
    int num_a = 1, num_b = 1;
    for (int i = 0; i < n; i++) {
        if (i > 0 && A[i].ff != A[i - 1].ff) num_a++;
        if (i > 0 && B[i].ff != B[i - 1].ff) num_b++;
        l[A[i].ss] = num_a, r[B[i].ss] = num_b;
    }
}

void update(int n, int x, int val) {
    while (x <= n) {
        tree[x] = max(tree[x], val);
        x += (x & -x);
    }
}

void update2(int n, int x) {
    while (x <= n) {
        tree[x] = 0;
        x += (x & -x);
    }
}

int query(int x) {
    int mx = 0;
    while (x > 0) {
        mx = max(mx, tree[x]);
        x -= (x & -x);
    }
    return mx;
}

int n;
vector<pair<pii, int > > tem, seg;

void calc(int left, int right) {
    int mid = (left + right) >> 1;
    tem.clear(), seg.clear();
    for (int i = left; i <= mid; i++) {
        tem.pb({{l[i], r[i]}, dp[i]});
    }
    sort(all(tem));
    for (int i = mid + 1; i <= right ; i++) {
        seg.pb({{l[i], r[i]}, i});
    }
    sort(all(seg));
    for (int i = 0, j = 0; i < (int)seg.size(); i++) {
        while (j < (int)tem.size() && tem[j].ff.ff < seg[i].ff.ff) {
            update(n, tem[j].ff.ss, tem[j].ss);
            j++;
        }
        dp[seg[i].ss] = max(dp[seg[i].ss], query(seg[i].ff.ss - 1) + 1);
    }
    for (int i = 0; i < tem.size(); i++) {
        update2(n, tem[i].ff.ss);
    }
}

void divide(int left, int right) {
    if (left == right) return;
    int mid = (left + right) >> 1;
    divide(left, mid);
    calc(left, right);
    divide(mid + 1, right);
}

int solve() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &l[i], &r[i]);
        dp[i] = 1;
    }
    compress(n);
    divide(1, n);
    int ans = 1;
    for (int i = 1; i <= n; i++) {
        ans = max(ans, dp[i]);
    }
    printf("%d\n", ans);
    return 0;
}

// Matrix Chain Multiplication

int row[N], col[N];
int dp[N][N];

int call(int l, int r) {
	if (l >= r) return 0;
	if (dp[l][r] != -1) return dp[l][r];
	int res = INT_MAX;
	for (int mid = l; mid < r; mid++) {
		res = min(res, call(l, mid) + call(mid + 1, r) + row[l] * col[mid] * col[r]);
	}
	return dp[l][r] = res;
}

// Maximum Value Without Adjacent

ll a[N];

int solve() {
    int n = in();
    for (int i = 1; i <= n; i++) {
        a[i] = Lin();
    }
    ll inc = 0, exc = 0;
    for (int i = 1; i <= n; i++) {
        ll tem = inc;
        inc = max(inc, exc + a[i]);
        exc = tem;
    }
    printf("%lld\n", max(inc, exc));
    return 0;
}

// Loghtoj 1071 - Baker Vai (Iterative DP)

int a[N][N], dp[N][N][N];
 
int solve() {
    fill(dp, 0);
    int n = in(), m = in();
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            a[i][j] = in();
        }
    }
    dp[1][1][2] = a[1][1] + a[1][2];
    for (int i = 3; i <= m; i++) {
        dp[1][1][i] += dp[1][1][i - 1] + a[1][i];
    }
    for (int i = 2; i <= n; i++) {
        // move down both L ans R
        for (int j = 1; j <= m - 1; j++) {
            for (int k = j + 1; k <= m; k++) {
                smax(dp[i][j][k], dp[i - 1][j][k] + a[i][j] + a[i][k]);
            }
        }
        // move L to the right
        for (int j = 2; j <= m - 1; j++) {
            for (int k = j + 1; k <= m; k++) {
                smax(dp[i][j][k], dp[i][j - 1][k] + a[i][j]);
            }
        }
        // move R to the right
        for (int j = 1; j <= m - 2; j++) {
            for (int k = j + 2; k <= m; k++) {
                smax(dp[i][j][k], dp[i][j][k - 1] + a[i][k]);
            }
        }
    }
    printf("%d\n", dp[n][m - 1][m]);
    return 0;
}

// Bitmask DP

std::vector<int> dp;
std::vector<vi> w;

int bitmask(int mask, int n) {
	if (mask == (1 << n) - 1)  return 0;
	if (dp[mask] != -1)  return dp[mask];
	int ans = 1 << 30;
	for (int i = 0; i < n; i++) {
		if (!(mask & (1 << i))) {
			int price = w[i][i];
			for (int j = 0; j < n; j++) {
				if (i != j && (mask & (1 << j)))
					price += w[i][j];
			}
			price += bitmask(mask ^ (1 << i), n);
			ans = min(ans, price);
		}
	}
	return dp[mask] = ans;
}

int solve() {
	int n = in();
	dp.resize(1 << n, -1);
	w.resize(n, vi(n, 0));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			w[i][j] = in();
		}
	}
	printf("%d\n", bitmask(0, n));
	return 0;
}

// Travelling Salesman Problem (Bitmask DP)

int n, dis[20][20];
ll dp[1 << 20 + 2][20];

ll tsp(int mask, int at) {
    if (mask == (1 << n) - 1) return (ll)dis[at][0];
    if (dp[mask][at] != -1) return dp[mask][at];
    ll res = inf;
    for (int i = 0; i < n; i++) {
        if (!(mask & (1 << i))) {
            res = min(res, tsp(mask ^ (1 << i), i) + dis[at][i]);
        }
    }
    return dp[mask][at] = res;
}

int solve() {
    n = in();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dis[i][j] = in();
        }
    }
    fill(dp, -1);
    printf("%lld\n", tsp(1, 0));
    return 0;
}

// Lightoj 1264 - Grouping Friends (Bitmask DP)

int dp[1 << 14], pre[1 << 14], a[14][14];

int bitmask(int mask) {
	if (mask == 0) return 0;
	int& ans = dp[mask];
	if (ans != -1) return ans;
	ans = 0;
	for (int i = mask; i > 0; i = ((i - 1) & mask)) {
		if (pre[i] > 0) continue;
		smin(ans, bitmask(mask ^ i) + pre[i]);
	}
	return ans;
}

int solve() {
	int n = in();
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			a[i][j] = in();
		}
	}
	for (int mask = 0; mask < (1 << n); mask++) {
		dp[mask] = -1, pre[mask] = 0;
	}
	for (int mask = 0; mask < (1 << n); mask++) {
		dp[mask] = -1, pre[mask] = 0;
		for (int i = 0; i < n; i++) {
			if (mask & (1 << i)) {
				for (int j = i + 1; j < n; j++) {
					if (mask & (1 << j)) pre[mask] += a[i][j] + a[j][i];
				}
			}
		}
	}
	printf("%d\n", bitmask((1 << n) - 1));
	return 0;
}

************************************************************

// Data Structures

// Binary Indexed Tree or Fenwick Tree

struct BIT {

    std::vector<ll> bit;
    int n;

    BIT() {
        n = N;
        bit.resize(n + 1, 0);
    }

    void update(int x, ll val) {
        while (x <= n) {
            bit[x] += val;
            x += (x & -x);
        }
    }

    ll query(int x) {
        ll sum = 0;
        while (x > 0) {
            sum += bit[x];
            x -= (x & -x);
        }
        return sum;
    }

    ll query(int l, int r) {
        return query(r) - query(l - 1);
    }
};

// Binary Indexed Tree 2D

struct BIT_TWO {

	std::vector<vl> bit;
	int n, m;

	BIT_TWO() {
		n = N, m = N;
		bit.resize(n + 1, vl(m + 1, 0));
	}

	void update(int x, int y, ll val) {
		while (x <= n) {
			int s = y;
			while (s <= m) {
				bit[x][s] += val;
				s += (s & -s);
			}
			x += (x & -x);
		}
	}

	ll query(int x, int y) {
		ll sum = 0LL;
		while (x > 0) {
			int s = y;
			while (s > 0) {
				sum += bit[x][s];
				s -= (s & -s);
			}
			x -= (x & -x);
		}
		return sum;
	}

	ll query(int x1, int y1, int x2, int y2) {
		return query(x2, y2) + query(x1 - 1, y1 - 1) - query(x1 - 1, y2) - query(x2, y1 - 1);
	}
};

// Binary Indexed Tree (Range Update & Range Query)

struct BIT_RANGE {

    std::vector<ll> pre, sum;
    int n;

    BIT_RANGE() {
        n = N;
        pre.resize(n + 1, 0);
        sum.resize(n + 1, 0);
    }

    void update(vector<ll>& bit, int x, ll val) {
        while (x <= n) {
            bit[x] += val;
            x += (x & -x);
        }
    }

    void update(int l, int r, ll val) {
        update(sum, l, val);
        update(sum, r + 1, -val);
        update(pre, l, val * (l - 1));
        update(pre, r + 1, -val * r);
    }

    ll query(std::vector<ll>& bit, int x) {
        ll ans = 0;
        while (x > 0) {
            ans += bit[x];
            x -= (x & -x);
        }
        return ans;
    }

    ll query(int l, int r) {
        ll ans = 0;
        ans += query(sum, r) * r - query(pre, r);
        ans -= query(sum, l - 1) * (l - 1) - query(pre, l - 1);
        return ans;
    }
};

// Segment Tree (Single update & Range Query)

ll a[N];

struct Seg_tree_sum {

	std::vector<ll> node;

	Seg_tree_sum() {
		node.resize(4 * N);
	}

	void build(int pos, int left, int right) {
		if (left == right) {
			node[pos] = a[left];
			return;
		}
		int mid = (left + right) >> 1;
		build(pos * 2, left, mid);
		build(pos * 2 + 1, mid + 1, right);
		node[pos] = node[pos * 2] + node[pos * 2 + 1];
	}

	void update(int pos, int left, int right, int x, ll val) {
		if (left > x || right < x) return;
		if (left == right) {
			node[pos] += val;
			return;
		}
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x, val);
		update(pos * 2 + 1, mid + 1, right, x, val);
		node[pos] = node[pos * 2] + node[pos * 2 + 1];
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0LL;
		if (left >= x && right <= y) return node[pos];
		int mid = (left + right) >> 1;
		ll m = query(pos * 2, left, mid, x, y);
		ll n = query(pos * 2 + 1, mid + 1, right, x, y);
		return m + n;
	}
};

// Segment Tree Lazy (Range Update & Range Query)

ll a[N];

struct Seg_tree_lazy_sum {

	std::vector<ll> node, prop;

	Seg_tree_lazy_sum() {
		node.resize(4 * N, 0);
		prop.resize(4 * N, 0);
	}

	void build(int pos, int left, int right) {
		if (left == right) {
			node[pos] = a[left];
			return;
		}
		int mid = (left + right) >> 1;
		build(pos * 2, left, mid);
		build(pos * 2 + 1, mid + 1, right);
		node[pos] = node[pos * 2] + node[pos * 2 + 1];
	}

	void propagate(int pos) {
		node[pos * 2] += prop[pos];
		node[pos * 2 + 1] += prop[pos];
		prop[pos * 2] += prop[pos];
		prop[pos * 2 + 1] += prop[pos];
		prop[pos] = 0;
	}

	void update(int pos, int left, int right, int x, int y, ll val) {
		if (left > y || right < x) return;
		if (left >= x && right <= y) {
			node[pos] += val;
			prop[pos] += val;
			return;
		}
		if (prop[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x, y, val);
		update(pos * 2 + 1, mid + 1, right, x, y, val);
		node[pos] = node[pos * 2] + node[pos * 2 + 1];
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return node[pos];
		if (prop[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		ll m = query(pos * 2, left, mid, x, y);
		ll n = query(pos * 2 + 1, mid + 1, right, x, y);
		return m + n;
	}
};

// Dynamic Segment Tree (Single Update & Range Query)

struct Dynamic_Seg_tree_sum {

	std::vector<ll> node;
	std::vector<int> l, r;

	Dynamic_Seg_tree_sum() {
		node.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void get_id(int& x) {
		x = sz(node);
		node.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void update(int pos, int left, int right, int x, ll val) {
		if (left == right) {
			node[pos] += val;
			return;
		}
		node[pos] += val;
		int mid = (left + right) >> 1;
		if (x <= mid) {
			if (l[pos] == -1) get_id(l[pos]);
			update(l[pos], left, mid, x, val);
		}
		else {
			if (r[pos] == -1) get_id(r[pos]);
			update(r[pos], mid + 1, right, x, val);
		}
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y)  return node[pos];
		int mid = (left + right) >> 1;
		ll ans = 0;
		if (l[pos] != -1) ans += query(l[pos], left, mid, x, y);
		if (r[pos] != -1) ans += query(r[pos], mid + 1, right, x, y);
		return ans;
	}
};

// Dynamic Segment Tree Lazy (Range Update & Range Query)

struct Dynamic_seg_tree_lazy_sum {
	std::vector<ll> node, prop;
	std::vector<int> l, r;

	Dynamic_seg_tree_lazy_sum() {
		node.push_back(0);
		prop.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void get_id(int& x) {
		x = sz(node);
		node.push_back(0);
		prop.push_back(0);
		l.push_back(-1);
		r.push_back(-1);
	}

	void propagate(int pos, int left, int right) {
		ll val = prop[pos];
		prop[pos] = 0;
		if (l[pos] == -1) get_id(l[pos]);
		if (r[pos] == -1) get_id(r[pos]);
		int mid = (left + right) >> 1;
		node[l[pos]] += val * (mid - left + 1);
		node[r[pos]] += val * (right - mid);
		prop[l[pos]] += val;
		prop[r[pos]] += val;
	}

	void update(int pos, int left, int right, int x, int y, ll val) {
		if(left > y || right < x) return;
		if (left >= x && right <= y) {
			node[pos] += val * (right - left + 1);
			prop[pos] += val;
			return;
		}
		if (prop[pos]) propagate(pos, left, right);
		int mid = (left + right) >> 1;
		if (x <= mid) {
			if (l[pos] == -1) get_id(l[pos]);
			update(l[pos], left, mid, x, y, val);
		}
		if (y > mid) {
			if (r[pos] == -1) get_id(r[pos]);
			update(r[pos], mid + 1, right, x, y, val);
		}
		node[pos] = 0;
		if (l[pos] != -1) node[pos] += node[l[pos]];
		if (r[pos] != -1) node[pos] += node[r[pos]];
	}

	ll query(int pos, int left, int right, int x, int y) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return node[pos];
		if (prop[pos]) propagate(pos, left, right);
		int mid = (left + right) >> 1;
		ll ans = 0;
		if (l[pos] != -1) ans += query(l[pos], left, mid, x, y);
		if (r[pos] != -1) ans += query(r[pos], mid + 1, right, x, y);
		return ans;
	}
};

// Segment Tree 2D (Single Update & Range Query)

int n;
ll a[N][N];

struct Seg_tree_sum_two {

	std::vector<vl> node;

	Seg_tree_sum_two() {
		node.resize(4 * N, vl(4 * N, 0));
	}

	void update_init(int pos, int left, int right, int y, ll val, int p) {
		if (left > y || right < y) return;
		if (left == right) {
			node[p][pos] += val;
			return;
		}
		int mid = (left + right) >> 1;
		update_init(pos * 2, left, mid, y, val, p);
		update_init(pos * 2 + 1, mid + 1, right, y, val, p);
		node[p][pos] = node[p][pos * 2] + node[p][pos * 2 + 1];
	}

	void update_merge(int pos, int left, int right, int y, int p) {
		if (left > y || right < y) return;
		if (left == right) {
			node[p][pos] = node[p * 2][pos] + node[p * 2 + 1][pos];
			return;
		}
		int mid = (left + right) >> 1;
		update_merge(pos * 2, left, mid, y, p);
		update_merge(pos * 2 + 1, mid + 1, right, y, p);
		node[p][pos] = node[p * 2][pos] + node[p * 2 + 1][pos];
	}

	void update(int pos, int left, int right, int x, int y, ll val) {
		if (left > x || right < x) return;
		if (left == right) {
			update_init(1, 1, n, y, val, pos);
			return;
		}
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x, y, val);
		update(pos * 2 + 1, mid + 1, right, x, y, val);
		update_merge(1, 1, n, y, pos);
	}

	ll query_merge(int pos, int left, int right, int y1, int y2, int p) {
		if (left > y2 || right < y1) return 0LL;
		if (left >= y1 && right <= y2) return node[p][pos];
		int mid = (left + right) >> 1;
		ll m = query_merge(pos * 2, left, mid, y1, y2, p);
		ll n = query_merge(pos * 2 + 1, mid + 1, right, y1, y2, p);
		return m + n;
	}

	ll query(int pos, int left, int right, int x1, int y1, int x2, int y2) {
		if (left > x2 || right < x1) return 0LL;
		if (left >= x1 && right <= x2) return query_merge(1, 1, n, y1, y2, pos);
		int mid = (left + right) >> 1;
		ll m = query(pos * 2, left, mid, x1, y1, x2, y2);
		ll n = query(pos * 2 + 1, mid + 1, right, x1, y1, x2, y2);
		return m + n;
	}
};

// Segment Tree Lazy 2D (Range Update & Range Query)

struct Seg_tree_lazy_sum_two {

	std::vector<vl> node, prop;

	Seg_tree_lazy_sum_two() {
		node.resize(4 * N, vl(4 * N, 0));
		prop.resize(4 * N, vl(4 * N, 0));
	}

	void propagate(int pos, int left, int right, int p) {
		int mid = (left + right) >> 1;
		ll val = prop[p][pos];
		prop[p][pos] = 0;
		node[p][pos * 2] += val * (mid - left + 1);
		node[p][pos * 2 + 1] += val * (right - mid);
		prop[p][pos * 2] += val;
		prop[p][pos * 2 + 1] += val;
	}

	void update_init(int pos, int left, int right, int y1, int y2, ll val, int p) {
		if (left > y2 || right < y1) return;
		if (left >= y1 && right <= y2) {
			node[p][pos] += val * (right - left + 1);
			prop[p][pos] += val;
			return;
		}
		if (prop[p][pos]) propagate(pos, left, right, p);
		int mid = (left + right) >> 1;
		update_init(pos * 2, left, mid, y1, y2, val, p);
		update_init(pos * 2 + 1, mid + 1, right, y1, y2, val, p);
		node[p][pos] = node[p][pos * 2] + node[p][pos * 2 + 1];
	}

	void update_merge(int pos, int left, int right, int y1, int y2, int p) {
		if (left > y2 || right < y1) return;
		if (left >= y1 && right <= y2) {
			node[p][pos] = node[p * 2][pos] + node[p * 2 + 1][pos];
			return;
		}
		if (prop[p][pos]) propagate(pos, left, right, p);
		int mid = (left + right) >> 1;
		update_merge(pos * 2, left, mid, y1, y2, p);
		update_merge(pos * 2 + 1, mid + 1, right, y1, y2, p);
		node[p][pos] = node[p * 2][pos] + node[p * 2 + 1][pos];
	}

	void update(int pos, int left, int right, int x1, int y1, int x2, int y2, ll val) {
		if (left > x2 || right < x1) return;
		if (left >= x1 && right <= x2) {
			update_init(1, 1, n, y1, y2, val * (right - left + 1), pos);
			return;
		}
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x1, y1, x2, y2, val);
		update(pos * 2 + 1, mid + 1, right, x1, y1, x2, y2, val);
		update_merge(1, 1, n, y1, y2, pos);
	}

	ll query_merge(int pos, int left, int right, int y1, int y2, int p) {
		if (left > y2 || right < y1) return 0LL;
		if (left >= y1 && right <= y2) return node[p][pos];
		if (prop[p][pos]) propagate(pos, left, right, p);
		int mid = (left + right) >> 1;
		ll m = query_merge(pos * 2, left, mid, y1, y2, p);
		ll n = query_merge(pos * 2 + 1, mid + 1, right, y1, y2, p);
		return m + n;
	}

	ll query(int pos, int left, int right, int x1, int y1, int x2, int y2) {
		if (left > x2 || right < x1) return 0LL;
		if (left >= x1 && right <= x2) return query_merge(1, 1, n, y1, y2, pos);
		int mid = (left + right) >> 1;
		ll m = query(pos * 2, left, mid, x1, y1, x2, y2);
		ll n = query(pos * 2 + 1, mid + 1, right, x1, y1, x2, y2);
		return m + n;
	}
};

// Kth Number in a Range (persistent Segment Tree)

struct kth_min_range {

    int idx;
    std::vector<int> a, b, c;
    std::vector<int> node, l, r, root;

    kth_min_range() {
        idx = 1;

        a.resize(N);
        b.resize(N);
        c.resize(N);

        node.resize(N * 50);
        l.resize(N * 50);
        r.resize(N * 50);
        root.resize(N * 50);
    }

    void compress(int n) {
        vii tem;
        for (int i = 1; i <= n; i++) {
            tem.pb({a[i], i});
        }
        sort(all(tem));
        int cur = 1;
        for (int i = 0; i < n; i++) {
            if (i > 0 && tem[i].ff != tem[i - 1].ff) cur++;
            b[tem[i].ss] = cur;
        }
        for (int i = 1; i <= n; i++) {
            c[b[i]] = a[i];
        }
    }

    void build(int pos, int left, int right) {
        if (left == right) return;
        int mid = (left + right) >> 1;
        l[pos] = ++idx;
        r[pos] = ++idx;
        build(l[pos], left, mid);
        build(r[pos], mid + 1, right);
    }

    int update(int pos, int left, int right, int x) {
        if (left > x || right < x) return pos;
        int id = ++idx;
        if (left == right) {
            node[id] = node[pos] + 1;
            return id;
        }
        int mid = (left + right) >> 1;
        l[id] = update(l[pos], left, mid, x);
        r[id] = update(r[pos], mid + 1, right, x);
        node[id] = node[l[id]] + node[r[id]];
        return id;
    }

    int query(int pos1, int pos2, int left, int right, int k) {
        if (left == right) return c[left];
        int mid = (left + right) >> 1;
        int cnt = node[l[pos2]] - node[l[pos1]];
        if (cnt >= k) return query(l[pos1], l[pos2], left, mid, k);
        else return query(r[pos1], r[pos2], mid + 1, right, k - cnt);
    }
};

int solve() {
    int n = in(), q = in();
    kth_min_range dp;
    for (int i = 1; i <= n ; i++) {
        dp.a[i] = in();
    }
    dp.compress(n);
    dp.root[0] = 1;
    dp.build(dp.root[0], 1, n);
    for (int i = 1; i <= n; i++) {
        dp.root[i] = dp.update(dp.root[i - 1], 1, n, dp.b[i]);
    }
    while (q--) {
        int x = in(), y = in(), k = in();
        printf("%d\n", dp.query(dp.root[x - 1], dp.root[y], 1, n, k));
    }
    return 0;
}

// Kth number In Tree (Persistent Segment Tree)

struct kth_min_tree {

    int idx;
    std::vector<int> a, b, c;
    std::vector<int> node, l, r, root;

    std::vector<int> dep;
    std::vector<bool> vis;
    std::vector<vi> g, par;

    kth_min_tree() {
        idx = 2;
        a.resize(N);
        b.resize(N);
        c.resize(N);

        node.resize(N * 50);
        l.resize(N * 50);
        r.resize(N * 50);
        root.resize(N * 50);

        g.resize(N);
        par.resize(17, vi(N, 1));
        vis.resize(N, false);
        dep.resize(N, 0);
    }

    int compress(int n) {
        vii tem;
        for (int i = 1; i <= n ; i++) {
            tem.pb({a[i], i});
        }
        sort(all(tem));
        int cur = 1;
        for (int i = 0; i < n; i++) {
            if (i > 0 && tem[i].ff != tem[i - 1].ff) cur++;
            b[tem[i].ss] = cur;
            c[b[tem[i].ss]] = a[tem[i].ss];
        }
        return cur;
    }

    void build(int pos, int left, int right) {
        if (left == right) return;
        int mid = (left + right) >> 1;
        l[pos] = idx++;
        r[pos] = idx++;
        build(l[pos], left, mid);
        build(r[pos], mid + 1, right);
    }

    int update(int pos, int left, int right, int x) {
        if (left > x || right < x) return pos;
        int id = idx++;
        if (left == right) {
            node[id] = node[pos] + 1;
            return id;
        }
        int mid = (left + right) >> 1;
        l[id] = update(l[pos], left, mid, x);
        r[id] = update(r[pos], mid + 1, right, x);
        node[id] = node[l[id]] + node[r[id]];
        return id;
    }

    int query(int pos1, int pos2, int pos3, int pos4, int left, int right, int k) {
        if (left == right) return c[left];
        int mid = (left + right) >> 1;
        int cnt = node[l[pos1]] + node[l[pos2]] - node[l[pos3]] - node[l[pos4]];
        if (cnt >= k) return query(l[pos1], l[pos2], l[pos3], l[pos4], left, mid, k);
        else return query(r[pos1], r[pos2], r[pos3], r[pos4], mid + 1, right, k - cnt);
    }

    void add_edge(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    void dfs(int n, int u, int p, int d = 1) {
        vis[u] = true, dep[u] = d;
        root[u] = update(root[p], 1, n, b[u]);
        for (int i = 1; i <= 16; i++) {
            par[i][u] = par[i - 1][par[i - 1][u]];
        }
        for (auto v : g[u]) {
            if (vis[v]) continue;
            par[0][v] = u;
            dfs(n, v, u, d + 1);
        }
    }

    int lca(int u, int v) {
        if (dep[u] < dep[v]) swap(u, v);
        for (int i = 16; i >= 0 && u != v; i--) {
            if (dep[par[i][u]] >= dep[v]) u = par[i][u];
        }
        if (u == v) return u;
        for (int i = 16; i >= 0; i--) {
            if (par[i][u] != par[i][v]) u = par[i][u], v = par[i][v];
        }
        return par[0][u];
    }
};

int solve() {
    int n = in(), q = in();
    kth_min_tree dp;
    for (int i = 1; i <= n; i++) {
        dp.a[i] = in();
    }
    int mx = dp.compress(n);
    for (int i = 1; i < n ; i++) {
        int u = in(), v = in();
        dp.add_edge(u, v);
    }

    dp.par[0][1] = 1;
    dp.root[0] = 1;
    dp.build(1, 1, mx);
    dp.dfs(mx, 1, 0);
    while (q--) {
        int u = in(), v = in(), k = in();
        int x = dp.lca(u, v);
        int y = dp.par[0][x];
        if (x == 1) y = 0;
        int ans = dp.query(dp.root[u], dp.root[v], dp.root[x], dp.root[y], 1, mx, k);
        printf("%d\n", ans);
    }
    return 0;
}

// Merge Sort Tree 

struct Merge_sort_tree {

	std::vector<vi> node;

	Merge_sort_tree() {
		node.resize(4 * N);
	}

	void build(int pos, int left, int right) {
		if (left == right) {
			node[pos].push_back(a[left]);
			return;
		}
		int mid = (left + right) >> 1;
		build(pos * 2, left, mid);
		build(pos * 2 + 1, mid + 1, right);
		merge(all(node[pos * 2]), all(node[pos * 2 + 1]), back_inserter(node[pos]));
	}

	int query(int pos, int left, int right, int x, int y, int p, int q) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return upper_bound(all(node[pos]), q) - lower_bound(all(node[pos]), p);
		int mid = (left + right) >> 1;
		int m = query(pos * 2, left, mid, x, y, p, q);
		int n = query(pos * 2 + 1, mid + 1, right, x, y, p, q);
		return m + n;
	}

	int query_mn(int pos, int left, int right, int x, int y, int p, int q) {
		if (left > y || right < x) return inf;
		if (left >= x && right <= y) {
			int cnt = upper_bound(all(node[pos]), q) - lower_bound(all(node[pos]), p);
			if (!cnt) return inf;
			return *lower_bound(all(node[pos]), p);
		}
		int mid = (left + right) >> 1;
		int m = query_mn(pos * 2, left, mid, x, y, p, q);
		int n = query_mn(pos * 2 + 1, mid + 1, right, x, y, p, q);
		return min(m, n);
	}

	int query_mx(int pos, int left, int right, int x, int y, int p, int q) {
		if (left > y || right < x) return -inf;
		if (left >= x && right <= y) {
			int cnt = upper_bound(all(node[pos]), q) - lower_bound(all(node[pos]), p);
			if (!cnt) return -inf;
			auto it = upper_bound(all(node[pos]), q);
			--it;
			return *it;
		}
		int mid = (left + right) >> 1;
		int m = query_mx(pos * 2, left, mid, x, y, p, q);
		int n = query_mx(pos * 2 + 1, mid + 1, right, x, y, p, q);
		return max(m, n);
	}
};

int solve() {
	int n = in(), q = in();
	for (int i = 1; i <= n; i++) {
		a[i] = in();
	}
	Merge_sort_tree dp;
	dp.build(1, 1, n);
	while (q--) {
		int l = in(), r = in(), p = in(), q = in();
		int cnt = dp.query(1, 1, n, l, r, p, q);
		int x = -1, y = -1;
		if (cnt) {
			x = dp.query_mn(1, 1, n, l, r, p, q);
			y = dp.query_mx(1, 1, n, l, r, p, q);
		}
		printf("%d %d %d\n", cnt, x, y);
	}
	return 0;
}

// Treap Data Structure

struct item {
    int p, sz;
    long long sm, k;
    item *L, *R;
    item(int k, int p) : k(k), p(p), sz(0), sm(0), L(NULL), R(NULL) {}
};

typedef item* node;

int size(node cur) {
    return cur ? cur -> sz : 0;
}

long long sum(node cur) {
    return cur ? cur -> sm : 0;
}

void upd_sz(node cur) {
    if (cur) cur -> sz = 1 + size(cur -> L) + size(cur -> R);
}

void upd_sm(node cur) {
    if (cur) cur -> sm = cur -> k + sum(cur -> L) + sum(cur -> R);
}

void split(node cur, node &L, node &R, int k) {
    if (cur == NULL) L = R = NULL;
    else if (cur -> k > k) split(cur -> L, L, cur -> L, k), R = cur;
    else split(cur -> R, cur -> R, R, k), L = cur;
    upd_sz(cur), upd_sm(cur);
}

void insert(node &cur, node nw) {
    if (cur == NULL) cur = nw;
    else if (nw -> p > cur -> p) split(cur, nw -> L, nw -> R, nw -> k), cur = nw;
    else insert(cur -> k < nw -> k ? cur -> R : cur -> L, nw);
    upd_sz(cur), upd_sm(cur);
}

void merge(node &cur, node L, node R) {
    if (L == NULL or R == NULL) cur = L ? L : R;
    else if (L -> p > R -> p) merge(L -> R, L -> R, R), cur = L;
    else merge(R -> L, L, R -> L), cur = R;
    upd_sz(cur), upd_sm(cur);
}

void erase(node &cur, int k) {
    if (!cur) return;
    if (cur -> k == k) {
        node temp = cur;
        merge(cur, cur -> L, cur -> R);
        delete temp;
    } else erase(cur -> k < k ? cur -> R : cur -> L, k);
    upd_sz(cur), upd_sm(cur);
}

long long kth_sum(node cur, int k) {
    if (!cur) return 0;
    if (k == size(cur -> L) + 1) return cur -> k + sum(cur -> L);
    if (k <= size(cur -> L)) return kth_sum(cur -> L, k);
    else return cur -> k + sum(cur -> L) + kth_sum(cur -> R, k - size(cur -> L) - 1);
}

int n, B;
long long a[N], res[N];

struct MO {
    int L, R, K, id;
    bool operator < (const MO &x) const {
        return L / B == x.L / B ? R < x.R : L / B < x.L / B;
    }
} q[N];

int solve() {
    node root = NULL;
    scanf("%d", &n);
    B = sqrt(n);
    for (int i = 1; i <= n; i++) scanf("%lld", a + i);
    int m;
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &q[i].L, &q[i].R, &q[i].K);
        q[i].id = i;
    }
    sort(q + 1, q + m + 1);
    int L = 1, R = 0;
    for (int i = 1; i <= m; i++) {
        while (L > q[i].L) insert(root, new item(a[--L], rand()));
        while (R < q[i].R) insert(root, new item(a[++R], rand()));
        while (L < q[i].L) erase(root, a[L++]);
        while (R > q[i].R) erase(root, a[R--]);
        res[q[i].id] = kth_sum(root, q[i].K) % MOD;
    }
    for (int i = 1; i <= m; i++) {
        printf("%lld\n", res[i]);
    }
    return 0;
}

// Sparse Table (Max Query)

ll a[N];

struct Sparse_table_max {

	std::vector<vl> table;

	Sparse_table_max() {
		table.resize(N, vl(18, 0));
	}

	void build(int n) {
		for (int i = 1; i <= n; i++) {
			table[i][0] = a[i];
		}
		for (int j = 1; (1 << j) <= n; j++) {
			for (int i = 1; i + (1 << j) - 1 <= n; i++) {
				table[i][j] = max(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);
			}
		}
	}

	ll query(int l, int r) {
		int k = log2(r - l + 1);
		return max(table[l][k], table[r + 1 - (1 << k)][k]);
	}
};

// Sparse Table 2D (Max Query)

int a[N][N];


struct Sparse_table_max_two {

	std::vector<vector<vector<vi>>> table;

	Sparse_table_max_two() {
		table.resize(N, vector<vector<vi>>(11, vector<vi>(N, vi(11, 0))));
	}

	void build(int n, int m) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				table[i][0][j][0] = a[i][j];
			}
			for (int k = 1; (1 << k) <= m; k++) {
				for (int j = 1; j + (1 << (k - 1)) - 1 <= m; j++) {
					table[i][0][j][k] = max(table[i][0][j][k - 1], table[i][0][j + (1 << (k - 1))][k - 1]);
				}
			}
		}
		for (int k = 1; (1 << k) <= n; k++) {
			for (int i = 1; i + (1 << k) - 1 <= n; i++) {
				for (int l = 0; (1 << l) <= m; l++) {
					for (int j = 1; j + (1 << l) - 1 <= m; j++) {
						table[i][k][j][l] = max(table[i][k - 1][j][l], table[i + (1 << (k - 1))][k - 1][j][l]);
					}
				}
			}
		}
	}

	int query(int x1, int y1, int x2, int y2) {
		int k = log2(x2 - x1 + 1), l = log2(y2 - y1 + 1);
		int r1 = max(table[x1][k][y1][l], table[x1][k][y2 + 1 - (1 << l)][l]);
		int r2 = max(table[x2 + 1 - (1 << k)][k][y1][l], table[x2 + 1 - (1 << k)][k][y2 + 1 - (1 << l)][l]);
		return max(r1, r2);
	}
};

// MO Algo (Offline)

int a[N], k;

bool cmp(const pair<pii, int> x, const pair<pii, int> y) {
	if (x.ff.ff / k != y.ff.ss / k) return (x < y);
	return ((x.ff.ff / k) & 1) ? (x.ff.ss < y.ff.ss) : (x.ff.ss > y.ff.ss);
}

struct MO_Algo {

	vector<pair<pii, int> > qry;
	int cur_res;
	std::vector<int> cnt, ans;

	MO_Algo() {
		cur_res = 0;
		cnt.resize(N, 0);
		ans.resize(N, 0);
	}

	void add(int x) {
		cnt[a[x]]++;
		if (cnt[a[x]] == 1) cur_res++;
	}

	void remove(int x) {
		cnt[a[x]]--;
		if (cnt[a[x]] == 0) cur_res--;
	}

	void add(int i, int l, int r) {
		qry.push_back(mp(mp(l, r), i));
	}

	void process(int n, int q) {
		k = sqrt(n);
		sort(all(qry), cmp);
		int cur_l = 1, cur_r = 0;
		for (int i = 0; i < q; i++) {
			int l = qry[i].ff.ff, r = qry[i].ff.ss, id = qry[i].ss;
			while (cur_l > l) add(--cur_l);
			while (cur_r < r) add(++cur_r);
			while (cur_l < l) remove(cur_l++);
			while (cur_r > r) remove(cur_r--);
			ans[id] = cur_res;
		}
	}
};

int solve() {
	int n = in();
	for (int i = 1; i <= n; i++) {
		a[i] = in();
	}
	MO_Algo dp;
	int q = in();
	for (int i = 1; i <= q; i++) {
		int l = in(), r = in();
		dp.add(i, l, r);
	}
	dp.process(n, q);
	for (int i = 1; i <= q; i++) {
		printf("%d\n", dp.ans[i]);
	}
	return 0;
}

// MO Algo With Update (Offline)

int a[N], last[N], k;

struct query {
	int l, r, t, id;
	query() {}
	query(int _l, int _r, int _t, int _id) : l(_l), r(_r), t(_t), id(_id) {}
};

bool cmp(const query a, const query b) {
	int l1 = a.l / k, l2 = b.l / k;
	int r1 = a.r / k, r2 = b.r / k;
	if (l1 != l2) return l1 < l2;
	if (r1 != r2) return r1 < r2;
	return a.t < b.t;
}

struct update {
	int x, pre, now;
	update() {}
	update(int _x, int _pre, int _now) : x(_x), pre(_pre), now(_now) {}
};

struct Mo_with_update {

	std::vector<query> qry;
	std::vector<update> upd;
	int cur_res;
	std::vector<int> cnt;
	std::vector<int> ans;

	Mo_with_update() {
		cur_res = 0;
		cnt.resize(N, 0);
		ans.resize(N, 0);
	}

	void add_query(int l, int r, int id) {
		qry.push_back(query(l, r, sz(upd), id));
	}

	void add_update(int x, int y) {
		upd.push_back(update(x, last[x], y));
		last[x] = y;
	}

	void add(int x) {
		x = a[x];
		cnt[x]++;
		if (cnt[x] == 1) cur_res++;
	}

	void remove(int x) {
		x = a[x];
		cnt[x]--;
		if (cnt[x] == 0) cur_res--;
	}

	void apply(int x, int y, int l, int r) {
		if (l <= x && x <= r) {
			remove(x);
			a[x] = y;
			add(x);
		} else {
			a[x] = y;
		}
	}

	void process(int n) {
		k = pow(n, 2.0 / 3);
		int q = sz(qry);
		sort(all(qry), cmp);
		int l = 1, r = 0, t = 0;
		for (int i = 0; i < q; i++) {
			while (t < qry[i].t) t++, apply(upd[t - 1].x, upd[t - 1].now, l, r);
			while (t > qry[i].t) apply(upd[t - 1].x, upd[t - 1].pre, l, r), t--;

			while (l > qry[i].l) add(--l);
			while (r < qry[i].r) add(++r);
			while (l < qry[i].l) remove(l++);
			while (r > qry[i].r) remove(r--);

			ans[qry[i].id] = cur_res;
		}
	}
};

int solve() {
	int n = Int;
	for (int i = 1; i <= n; i++) {
		a[i] = Int;
		last[i] = a[i];
	}
	Mo_with_update dp;
	int q = Int;
	std::vector<bool> vis(q + 1, false);
	for (int i = 1; i <= q; i++) {
		int ck = Int;
		int x = Int, y = Int;
		if (ck == 1) dp.add_query(x, y, i), vis[i] = true;
		else dp.add_update(x, y);
	}
	dp.process(n);
	for (int i = 1; i <= q; i++) {
		if (vis[i]) printf("%d\n", dp.ans[i]);
	}
	return 0;
}

// Sliding Window (Max Query)

int a[N];

struct Sliding_Window_Max {

    vi window(int n, int k) {
        vi ans;
        deque <pii> dq;
        for (int i = 1; i <= n; i++) {
            while (!dq.empty() && dq.back().ff <= a[i]) {
                dq.pop_back();
            }
            dq.push_back(mp(a[i], i));
            while (dq.front().ss <= i - k) {
                dq.pop_front();
            }
            if (i >= k) ans.push_back(dq.front().ff);
        }
        return ans;
    }
};

// Minimum Element in queue

struct minimum_queue {

	deque<pair<int, int>> q;
	int cnt_added;
	int cnt_removed;

	minimum_queue() {
		q.clear();
		cnt_added = 0;
		cnt_removed = 0;
	}

	void add(int new_element) {
		while (!q.empty() && q.back().first > new_element) {
			q.pop_back();
		}
		q.push_back({new_element, cnt_added});
		cnt_added++;
	}

	void remove() {
		if (!q.empty() && q.front().second == cnt_removed) {
			q.pop_front();
		}
		cnt_removed++;
	}

	int get_ans() {
		return q.front().ff;
	}
};

// Minimum Element in Stack

struct minimum_stack {
	
	stack < pair<int, int> > st;

	minimum_stack() {
		while (!st.empty()) {
			st.pop();
		}
	}

	void add(int new_elem) {
		int new_min = st.empty() ? new_elem : min(new_elem, st.top().second);
		st.push({new_elem, new_min});
	}

	void remove() {
		st.pop();
	}

	int get_ans() {
		return st.top().ss;
	}
};

******************************************************************

// Graph Theory

// BFS Algorithm

struct Breadth_First_Search {

	std::vector<vi> g;
	std::vector<int> dis, par;
	std::vector<bool> vis;

	Breadth_First_Search() {
		g.resize(N);
		dis.resize(N, 0);
		par.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void bfs(int u) {
		queue<int> q;
		q.push(u);
		vis[u] = true;
		while (!q.empty()) {
			u = q.front();
			q.pop();
			for (auto v : g[u]) {
				if (!vis[v]) {
					dis[v] = dis[u] + 1;
					par[v] = u;
					vis[v] = true;
					q.push(v);
				}
			}
		}
	}

	void path(int u, int v) {
		if (par[v]) path(u, par[v]);
		if (u == v) printf("%d", v);
		else printf(" %d", v);
	}
};

// BFS Algorithm (Grid)

int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};

bool valid(int n, int m, int x, int y) {
	if (x >= 0 && x < n && y >= 0 && y < m) return true;
	return false;
}

string s[N];

struct Breadth_First_Search_Grid {

	std::vector<vi> dis;
	std::vector<vector<bool>> vis;
	std::vector<vii> par;

	Breadth_First_Search_Grid() {
		dis.resize(N, vi(N, 0));
		vis.resize(N, vector<bool>(N, false));
		par.resize(N, vii(N, mp(-1, -1)));
	}

	void bfs(int n, int m, int u, int v) {
		queue<pii>q;
		q.push(mp(u, v));
		vis[u][v] = true;
		while (!q.empty()) {
			u = q.front().ff, v = q.front().ss;
			q.pop();
			for (int i = 0; i < 4; i++) {
				int x = u + dr[i], y = v + dc[i];
				if (valid(n, m, x, y) && s[x][y] == '.' && !vis[x][y]) {
					dis[x][y] = dis[u][v] + 1;
					par[x][y] = mp(u, v);
					vis[x][y] = true;
					q.push(mp(x, y));
				}
			}
		}
	}

	void path(int u, int v, int x, int y) {
		if (par[x][y] != mp(-1, -1)) path(u, v, par[x][y].ff, par[x][y].ss);
		if (u == x && v == y) printf("(%d %d)", x + 1, y + 1);
		else printf(" (%d %d)", x + 1, y + 1);
	}
};

// BFS Algorithm (Chessboard)

int dr[] = {1, 1, -1, -1, 2, 2, -2, -2};
int dc[] = {2, -2, 2, -2, 1, -1, 1, -1};

bool valid(int n, int m, int x, int y) {
	if (x >= 1 && x <= n && y >= 1 && y <= m) return true;
	return false;
}

struct Breadth_First_Search_Chess {

	std::vector<vi> dis;
    std::vector<vector<bool>> vis;
	std::vector<vii> par;

	Breadth_First_Search_Chess() {
		dis.resize(N, vi(N, 0));
		vis.resize(N, vector<bool>(N, false));
		par.resize(N, vii(N, mp(-1, -1)));
	}

	void bfs(int n, int m, int u, int v) {
		queue<pii>q;
		q.push(mp(u, v));
		vis[u][v] = true;
		while (!q.empty()) {
			u = q.front().ff, v = q.front().ss;
			q.pop();
			for (int i = 0; i < 8; i++) {
				int x = u + dr[i], y = v + dc[i];
				if (valid(n, m, x, y) && !vis[x][y]) {
					dis[x][y] = dis[u][v] + 1;
					par[x][y] = mp(u, v);
					vis[x][y] = true;
					q.push(mp(x, y));
				}
			}
		}
	}

	void path(int u, int v, int x, int y) {
		if (par[x][y] != mp(-1, -1)) path(u, v, par[x][y].ff, par[x][y].ss);
		if (u == x && v == y) printf("(%d %d)", x, y);
		else printf(" (%d %d)", x, y);
	}
};

// Bicoloring Algorithm (BFS)

struct Bicoloring {

	std::vector<vi> g;
	std::vector<int> color;

	Bicoloring() {
		g.resize(N);
		color.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	bool bicoloring(int u) {
		queue<int> q;
		q.push(u);
		color[u] = 1;
		while (!q.empty()) {
			u = q.front();
			q.pop();
			for (auto v : g[u]) {
				if (!color[v]) {
					if (color[u] == 1) color[v] = 2;
					else color[v] = 1;
					q.push(v);
				}
				if (color[v] == color[u]) return false;
			}
		}
		return true;
	}

	bool get_result(int n) {
		bool ok = true;
		for (int i = 1; i <= n && ok; i++) {
			if (!color[i]) ok = bicoloring(i);
		}
		return ok;
	}
};

// DFS Algorithm

struct Depth_First_Search {

	std::vector<vi> g;
	std::vector<bool> vis;

	Depth_First_Search() {
		g.resize(N);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void dfs(int u) {
		vis[u] = true;
		for (auto v : g[u]) {
			if (!vis[v]) dfs(v);
		}
	}

	int get_component(int n) {
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			if (!vis[i]) ans++, dfs(i);
		}
		return ans;
	}
};

// DFS Algorithm (Grid)

int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};

bool valid(int n, int m, int x, int y) {
	if (x >= 0 && x < n && y >= 0 && y < m) return true;
	return false;
}

string s[N];

struct Depth_First_Search_Grid {

	std::vector<vector<bool>> vis;

	Depth_First_Search_Grid() {
		vis.resize(N, vector<bool>(N, false));
	}

	void dfs(int n, int m, int u, int v) {
		vis[u][v] = true;
		for (int i = 0; i < 4; i++) {
			int x = u + dr[i], y = v + dc[i];
			if (valid(n, m, x, y) && s[x][y] == '.' && !vis[x][y]) dfs(n, m, x, y);
		}
	}

	int get_component(int n, int m) {
		int ans = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (s[i][j] == '.' && !vis[i][j]) ans++, dfs(n, m, i, j);
			}
		}
		return ans;
	}
};

// Dijkstra Algorithm

struct Dijkstra_Algo {

	std::vector<vii> g;
	std::vector<ll> dis;
	std::vector<int> par;
	std::vector<bool> vis;

	Dijkstra_Algo() {
		g.resize(N);
		dis.resize(N, Inf);
		par.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v, int w) {
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}

	void dijkstra(int u) {
		dis[u] = 0;
		priority_queue<pli, vli, greater<pli> > pq;
		pq.push(mp(dis[u], u));
		while (!pq.empty()) {
			u = pq.top().ss;
			pq.pop();
			vis[u] = true;
			for (auto x : g[u]) {
				int v = x.ff;
				ll w = (ll)x.ss;
				if (dis[v] > dis[u] + w) {
					dis[v] = dis[u] + w, par[v] = u;
					if (!vis[v]) pq.push(mp(dis[v], v));
				}
			}
		}
	}

	void path(int u, int v) {
		if (par[v]) path(u, par[v]);
		if (u == v) printf("%d", v);
		else printf(" %d", v);
	}
};

// Bellman - Ford Algorithm

struct Bellman_Ford {

	std::vector<vii> g;
	std::vector<ll> dis;
	std::vector<int> par;

	Bellman_Ford() {
		g.resize(N);
		dis.resize(N, Inf);
		par.resize(N, 0);
	}

	void add_edge(int u, int v, int w) {
		g[u].push_back({v, w});
	}

	bool bellman_ford(int n, int s) {
		dis[s] = 0;
		for (int i = 1; i <= n; i++) {
			for (int u = 1; u <= n; u++) {
				for (auto x : g[u]) {
					int v = x.ff;
					ll w = (ll)x.ss;
					if (dis[v] > dis[u] + w) {
						if (i == n) return false;
						dis[v] = dis[u] + w;
						par[v] = u;
					}
				}
			}
		}
		return true;
	}

	void path(int u, int v) {
		if (par[v]) path(u, par[v]);
		if (u == v) printf("%d", v);
		else printf(" %d", v);
	}
};

// Floyd - Warshall Algorithm

struct Floyd_Warshall_Algo {

	std::vector<vl> dis;
	std::vector<vi> par;

	Floyd_Warshall_Algo() {
		dis.resize(N, vl(N, Inf));
		par.resize(N, vi(N, 0));
		for (int i = 1; i < N; i++) {
			for (int j = 1; j < N; j++) {
				if(i == j) dis[i][j] = 0;
				par[i][j] = j;
			}
		}
	}

	void add_edge(int u, int v, ll w) {
		dis[u][v] = w;
	}

	void floyd_warshall(int n) {
		for (int k = 1; k <= n; k++) {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					if (dis[i][j] > dis[i][k] + dis[k][j]) {
						dis[i][j] = dis[i][k] + dis[k][j];
						par[i][j] = par[i][k];
					}
				}
			}
		}
	}

	void path(int u, int v) {
		printf("%d ", u);
		if (u != v) {
			u = par[u][v];
			path(u, v);
		}
	}
};

// Diameter Of tree

struct Diameter {

	std::vector<vi> g;
	std::vector<int> mh, dm;

	Diameter() {
		g.resize(N);
		dm.resize(N, 0);
		mh.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void dfs(int u, int p = -1) {
		int mx_height = 0, second_mx_height = 0;
		for (auto v : g[u]) {
			if (p == v) continue;
			dfs(v, u);
			dm[u] = max(dm[u], dm[v]);
			mh[u] = max(mh[u], mh[v] + 1);
			smax(second_mx_height, mh[v] + 1);
			if (second_mx_height > mx_height) swap(mx_height, second_mx_height);
		}
		dm[u] = max(dm[u], mx_height + second_mx_height);
	}
};

// Topological Sort (BFS)

struct Topological_Sorting {

	std::vector<vi> g;
	std::vector<int> ts, degree;

	Topological_Sorting() {
		g.resize(N);
		degree.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		degree[v]++;
	}

	vi top_sort(int n) {
		queue<int>q;
		for (int i = 1; i <= n; i++) {
			if (!degree[i]) q.push(i);
		}
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			ts.push_back(u);
			degree[u] = -1;
			for (int i = 0; i < g[u].size(); i++) {
				int v = g[u][i];
				degree[v]--;
				if (!degree[v]) q.push(v);
			}
		}
		return ts;
	}
};

// Articulation Point

struct Articulation_Point {

	int t;
	std::vector<vi> g;
	std::vector<int> low, d, par, point;
	std::vector<bool> vis, p;

	Articulation_Point() {
		t = 0;
		g.resize(N);
		low.resize(N, 0);
		d.resize(N, 0);
		par.resize(N, 0);
		vis.resize(N, false);
		p.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void arti_point(int u) {
		vis[u] = true, low[u] = d[u] = ++t;
		int child = 0;
		for (auto v : g[u]) {
			if (v == par[u]) continue;
			if (!vis[v]) {
				par[v] = u, child++;
				arti_point(v);
				low[u] = min(low[u], low[v]);
				if (d[u] <= low[v] && u != 1) p[u] = true;
			} else
				low[u] = min(low[u], d[v]);
		}
		if (u == 1 && child > 1) p[u] = true;
	}

	vi get_result(int u, int n) {
		arti_point(u);
		for (int i = 1; i <= n; i++) {
			if (p[i]) point.push_back(i);
		}
		return point;
	}
};

// Articulation Bridge

struct Articulation_Bridge {

    int t;
	std::vector<vi> g;
	std::vector<int> low, d, par;
	std::vector<bool> vis;
	std::vector<pii> bridge;

	Articulation_Bridge() {
		t = 0;
		g.resize(N);
		low.resize(N, 0);
		d.resize(N, 0);
		par.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void arti_bridge(int u) {
		vis[u] = true;
		low[u] = d[u] = ++t;
		for (auto v : g[u]) {
			if (v == par[u]) continue;
			if (!vis[v]) {
				par[v] = u;
				arti_bridge(v);
				low[u] = min(low[u], low[v]);
				if (d[u] < low[v]) u <= v ? bridge.push_back(mp(u, v)) : bridge.push_back(mp(v, u));
			} else
				low[u] = min(low[u], d[v]);
		}
	}

	vii get_result(int u) {
        arti_bridge(1);
        return bridge;
	}
};

// Strongly Connected Component (Kossaraju Algorithm)

struct SCC_Kossaraju {

	std::vector<vi> g, rg, scc;
	std::vector<int> vis;
	stack<int> ts;

	SCC_Kossaraju() {
		g.resize(N);
		rg.resize(N);
		scc.resize(N);
		vis.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		rg[v].push_back(u);
	}

	void dfs(int u) {
		vis[u] = 1;
		for (auto v : g[u]) {
			if (!vis[v]) dfs(v);
		}
		ts.push(u);
	}

	void dfs2(int u, int k) {
		vis[u] = 2;
		scc[k].push_back(u);
		for (auto v : rg[u]) {
			if (vis[v] != 2) dfs2(v, k);
		}
	}

	int scc_process(int n) {
		int k = 0;
		for (int i = 1; i <= n; i++) {
			if (!vis[i]) dfs(i);
		}
		while (!ts.empty()) {
			int v = ts.top();
			ts.pop();
			if (vis[v] != 2) dfs2(v, ++k);
		}
		return k;
	}
};

// Strongly Connected Component (Tarjan Algorithm)

struct SCC_Tarjan {

	int t, k;
	std::vector<vi> g, scc;
	std::vector<int> low, d;
	std::vector<bool> vis;
	stack<int>ts;

	SCC_Tarjan() {
		t = k = 0;
		g.resize(N);
		scc.resize(N);
		low.resize(N, 0);
		d.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
	}

	void tarjan(int u) {
		vis[u] = true, ts.push(u), low[u] = d[u] = ++t;
		for (auto v : g[u]) {
			if (!d[v]) {
				tarjan(v);
				low[u] = min(low[u], low[v]);
			} else if (vis[v])
				low[u] = min(low[u], d[v]);
		}
		if (low[u] == d[u]) {
			int s;
			k++;
			do {
				s = ts.top();
				ts.pop();
				scc[k].pb(s);
				vis[s] = false;
			} while (s != u && !ts.empty());
		}
	}

	int get_result(int n) {
		for (int i = 1; i <= n; i++) {
			if (!d[i]) tarjan(i);
		}
		return k;
	}
};

// Minimum Spanning Tree (Krushkal)

struct Krushkal_Minimum_Spanning_Tree {

	ll ans;
	vector<pair<int, pii> >edge;
	std::vector<int> par, sz;

	Krushkal_Minimum_Spanning_Tree() {
		ans = 0;
		par.resize(N);
		sz.resize(N, 1);
		for (int i = 1; i < N; i++) {
			par[i] = i;
		}
	}

	void add_edge(int u, int v, int w) {
		edge.push_back({w, {u, v}});
	}

	int Find(int u) {
		return par[u] == u ? u : par[u] = Find(par[u]);
	}

	void Union(int u, int v, int w) {
		int x = Find(u);
		int y = Find(v);
		if (sz[x] < sz[y]) swap(x, y);
		if (x != y) ans += w, sz[x] += sz[y], par[y] = x;
	}

	ll krushkal(int n) {
		sort(all(edge));
		for (auto x : edge) {
			int u = x.ss.ff, v = x.ss.ss;
			ll w = (ll)x.ff;
			Union(u, v, w);
		}
		return ans;
	}
};

// Minimum Spanning Tree (prim)

struct Prim_Minimum_Spanning_Tree {

	std::vector<vii> g;
	std::vector<bool> vis;

	Prim_Minimum_Spanning_Tree() {
		g.resize(N);
		vis.resize(N, false);
	}

	void add_edge(int u, int v, int w) {
		g[u].push_back({w, v});
		g[v].push_back({w, u});
	}

	ll prim(int n, int u) {
		priority_queue<pii, vii, greater<pii> > pq;
		pq.push(mp(0, u));
		ll cost = 0LL;
		while (!pq.empty()) {
			u = pq.top().ss;
			ll w = (ll)pq.top().ff;
			pq.pop();
			if (!vis[u]) cost += w, vis[u] = true;
			for (auto x : g[u]) {
				int v = x.ss, wt = x.ff;
				if (!vis[v]) pq.push(mp(wt, v));
			}
		}
		return cost;
	}
};

// LCA Algorithm

struct Lowest_Common_Ancestor {

	std::vector<vi> g, par;
	std::vector<int> dep;
	std::vector<bool> vis;

	Lowest_Common_Ancestor() {
		g.resize(N);
		par.resize(18, vi(N, 1));
		dep.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void lca_build(int u, int d = 0) {
		vis[u] = true, dep[u] = d;
		for (int i = 1; i <= 17; i++) {
			par[i][u] = par[i - 1][par[i - 1][u]];
		}
		for (int i = 0; i < g[u].size(); i++) {
			int v = g[u][i];
			if (!vis[v]) {
				par[0][v] = u;
				lca_build(v, dep[u] + 1);
			}
		}
	}

	int lca_query(int u, int v) {
		if (dep[u] < dep[v]) swap(u, v);
		for (int i = 17; i >= 0 && u != v; i--) {
			if (dep[par[i][u]] >= dep[v]) u = par[i][u];
		}
		if (u == v) return u;
		for (int i = 17; i >= 0; i--) {
			if (par[i][u] != par[i][v]) u = par[i][u], v = par[i][v];
		}
		return par[0][u];
	}
};

// LCA Algorithm (Min & Max Edge)

struct LCA_Mn_Mx_Edge {

	std::vector<vii> g;
	std::vector<vi> par, mn, mx;
	std::vector<int> dep;
	std::vector<bool> vis;

	LCA_Mn_Mx_Edge() {
		g.resize(N);
		par.resize(18, vi(N, 1));
		mn.resize(18, vi(N, inf));
		mx.resize(18, vi(N, 0));
		dep.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v, int w) {
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}

	void dfs(int u, int d = 0) {
		vis[u] = true, dep[u] = d;
		for (int i = 1; i <= 17; i++) {
			par[i][u] = par[i - 1][par[i - 1][u]];
			mx[i][u] = max(mx[i - 1][u], mx[i - 1][par[i - 1][u]]);
			mn[i][u] = min(mn[i - 1][u], mn[i - 1][par[i - 1][u]]);
		}
		for (auto x : g[u]) {
			int v = x.ff, w = x.ss;
			if (!vis[v]) {
				par[0][v] = u, mx[0][v] = mn[0][v] = w;
				dfs(v, dep[u] + 1);
			}
		}
	}

	int maximum_edge(int u, int v) {
		int ans = INT_MIN;
		if (dep[u] < dep[v]) swap(u, v);
		for (int i = 17; i >= 0 && u != v; i--) {
			if (dep[par[i][u]] >= dep[v]) {
				ans = max(ans, mx[i][u]);
				u = par[i][u];
			}
		}
		if (u == v) return ans;
		for (int i = 17; i >= 0; i--) {
			if (par[i][u] >= par[i][v]) {
				ans = max(ans, max(mx[i][u], mx[i][v]));
				u = par[i][u], v = par[i][v];
			}
		}
		return max(ans, max(mx[0][u], mx[0][v]));
	}

	int minimum_edge(int u, int v) {
		int ans = INT_MAX;
		if (dep[u] < dep[v]) swap(u, v);
		for (int i = 17; i >= 0 && u != v; i--) {
			if (dep[par[i][u]] >= dep[v]) {
				ans = min(ans, mn[i][u]);
				u = par[i][u];
			}
		}
		if (u == v) return ans;
		for (int i = 17; i >= 0; i--) {
			if (par[i][u] >= par[i][v]) {
				ans = min(ans, min(mn[i][u], mn[i][v]));
				u = par[i][u], v = par[i][v];
			}
		}
		return min(ans, min(mn[0][u], mn[0][v]));
	}
};

// Centroid Decomposition (Number of pair of node whose distance is k)

int n, k;

struct Centroid_decompose {

	int nd;
	ll ans;
	std::vector<vi> g;
	std::vector<int> dis, sz;
	std::vector<bool> vis;

	Centroid_decompose() {
		nd = 0, ans = 0;
		g.resize(N);
		dis.resize(502, 0);
		sz.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void upd_dis(int u, int p, int d) {
		if (d > k)  return;
		dis[d]++;
		for (auto v : g[u]) {
			if (v != p && !vis[v]) upd_dis(v, u, d + 1);
		}
	}

	void upd_res(int u, int p, int d) {
		if (d > k)  return;
		ans += dis[k - d];
		for (auto v : g[u]) {
			if (v != p && !vis[v]) upd_res(v, u, d + 1);
		}
	}

	void getsz(int u, int p = -1) {
		sz[u] = 1, nd++;
		for (auto v : g[u]) {
			if (v != p && !vis[v]) getsz(v, u), sz[u] += sz[v];
		}
	}

	int centroid(int u, int p = -1) {
		for (auto v : g[u]) {
			if (v != p && !vis[v] && sz[v] > nd / 2) return centroid(v, u);
		}
		return u;
	}

	void decompose(int u, int p = -1) {
		dis.resize(502, 0);
		nd = 0, dis[0]++;
		getsz(u);
		int center = centroid(u);
		vis[center] = true;
		for (auto v : g[center]) {
			if (!vis[v]) {
				upd_res(v, center, 1);
				upd_dis(v, center, 1);
			}
		}
		for (auto v : g[center]) {
			if (!vis[v]) decompose(v, center);
		}
	}

	ll get_result(int u) {
        decompose(u);
		return ans;
	}
};

// Heavy Light Decomposition + LCA + BIT

int a[N];

struct Heavy_Light_Decompose_BIT {

	int num;
	std::vector<vi> g, bit, chain, par;
	std::vector<int> idx, pos, sz, dep;
	std::vector<bool> vis;

	Heavy_Light_Decompose_BIT() {
		num = 1;
		g.resize(N);
		bit.resize(N);
		chain.resize(N);
		par.resize(15, vi(N, 1));
		idx.resize(N, 0);
		pos.resize(N, 0);
		sz.resize(N, 0);
		dep.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void update(int n, int x, int c, int val) {
		while (x <= n) {
			bit[c][x] += val;
			x += (x & -x);
		}
	}

	int query(int x, int c) {
		int sum = 0;
		while (x > 0) {
			sum += bit[c][x];
			x -= (x & -x);
		}
		return sum;
	}

	void lca_build(int u, int d = 1) {
		vis[u] = true, sz[u] = 1, dep[u] = d;
		for (int i = 1; i <= 14; i++) {
			par[i][u] = par[i - 1][par[i - 1][u]];
		}
		for (auto v : g[u]) {
			if (!vis[v]) {
				par[0][v] = u;
				lca_build(v, dep[u] + 1);
				sz[u] += sz[v];
			}
		}
	}

	int lca_query(int u, int v) {
		if (dep[u] < dep[v]) swap(u, v);
		for (int i = 14; i >= 0 && u != v; i--) {
			if (dep[par[i][u]] >= dep[v]) u = par[i][u];
		}
		if (u == v) return u;
		for (int i = 14; i >= 0; i--) {
			if (par[i][u] != par[i][v]) u = par[i][u], v = par[i][v];
		}
		return par[0][u];
	}

	void hld_build(int u, int p = -1) {
		chain[num].push_back(u), idx[u] = num;
		pos[u] = sz(chain[num]);
		int mx = -1, bigchild = -1;
		for (auto v : g[u]) {
			if (v != p && sz[v] > mx) mx = sz[v], bigchild = v;
		}
		if (bigchild != -1) hld_build(bigchild, u);
		for (auto v : g[u]) {
			if (v != p && v != bigchild) num++, hld_build(v, u);
		}
	}

	void hld_process() {
		for (int i = 1; i <= num; i++) {
			for (int j = 0; j <= sz(chain[i]); j++) {
				bit[i].push_back(0);
			}
			for (int j = 0; j < sz(chain[i]); j++) {
				update(sz(chain[i]), j + 1, i, a[chain[i][j]]);
			}
		}
	}

	void update(int u, int val) {
		int x = pos[u], c = idx[u];
		update(sz(chain[c]), x, c, val);
	}

	int hld_query(int u, int v) {
		int l = lca_query(u, v), ans = 0;
		while (1) {
			int c = idx[u];
			if (idx[u] == idx[l]) {
				ans += query(pos[u], c) - query(pos[l] - 1, c);
				break;
			}
			ans += query(pos[u], c);
			u = par[0][chain[c][0]];
		}
		while (1) {
			int c = idx[v];
			if (idx[v] == idx[l]) {
				ans += query(pos[v], c) - query(pos[l], c);
				break;
			}
			ans += query(pos[v], c);
			v = par[0][chain[c][0]];
		}
		return ans;
	}
};

int solve() {
	int n = in();
	for (int i = 1; i <= n; i++) {
		a[i] = in();
	}
	Heavy_Light_Decompose_BIT graph;
	for (int i = 1; i < n; i++) {
		int u = in(), v = in();
		graph.add_edge(u, v);
	}
	graph.lca_build(1);
	graph.hld_build(1);
	graph.hld_process();
	int q = in();
	while (q--) {
		int ck = in();
		if (!ck) {
			int u = in(), val = in();
			graph.update(u, val);
		} else {
			int u = in(), v = in();
			printf("%d\n", graph.hld_query(u, v));
		}
	}
	return 0;
}

// Heavy Light Decomposition + LCA + Segment Tree

int a[N];

struct Heavy_light_Decompose_Seg_Tree {

	int num;
	std::vector<vi> g, node, chain, par;
	std::vector<int> idx, pos, sz, dep;
	std::vector<bool> vis;

	Heavy_light_Decompose_Seg_Tree() {
		num = 1;
		g.resize(N);
		node.resize(4 * N);
		chain.resize(N);
		par.resize(15, vi(N, 1));
		idx.resize(N, 0);
		pos.resize(N, 0);
		sz.resize(N, 0);
		dep.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void build(int pos, int left, int right, int c) {
		if (left == right) {
			node[c][pos] = a[chain[c][left - 1]];
			return;
		}
		int mid = (left + right) >> 1;
		build(pos * 2, left, mid, c);
		build(pos * 2 + 1, mid + 1, right, c);
		node[c][pos] = node[c][pos * 2] + node[c][pos * 2 + 1];
	}

	void update(int pos, int left, int right, int x, int val, int c) {
		if (left > x || right < x) return;
		if (left == right) {
			node[c][pos] += val;
			return;
		}
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x, val, c);
		update(pos * 2 + 1, mid + 1, right, x, val, c);
		node[c][pos] = node[c][pos * 2] + node[c][pos * 2 + 1];
	}

	int query(int pos, int left, int right, int x, int y, int c) {
		if (left > y || right < x) return 0;
		if (left >= x && right <= y) return node[c][pos];
		int mid = (left + right) >> 1;
		int m = query(pos * 2, left, mid, x, y, c);
		int n = query(pos * 2 + 1, mid + 1, right, x, y, c);
		return m + n;
	}

	void lca_build(int u, int d = 1) {
		vis[u] = true, sz[u] = 1, dep[u] = d;
		for (int i = 1; i <= 14; i++) {
			par[i][u] = par[i - 1][par[i - 1][u]];
		}
		for (auto v : g[u]) {
			if (!vis[v]) {
				par[0][v] = u;
				lca_build(v, dep[u] + 1);
				sz[u] += sz[v];
			}
		}
	}

	int lca_query(int u, int v) {
		if (dep[u] < dep[v]) swap(u, v);
		for (int i = 14; i >= 0 && u != v; i--) {
			if (dep[par[i][u]] >= dep[v]) u = par[i][u];
		}
		if (u == v) return u;
		for (int i = 14; i >= 0; i--) {
			if (par[i][u] != par[i][v]) u = par[i][u], v = par[i][v];
		}
		return par[0][u];
	}

	void hld_build(int u, int p = -1) {
		chain[num].push_back(u), idx[u] = num;
		pos[u] = sz(chain[num]);
		int mx = -1, bigchild = -1;
		for (auto v : g[u]) {
			if (v != p && sz[v] > mx) mx = sz[v], bigchild = v;
		}
		if (bigchild != -1) hld_build(bigchild, u);
		for (auto v : g[u]) {
			if (v != p && v != bigchild) num++, hld_build(v, u);
		}
	}

	void hld_process() {
		for (int i = 1; i <= num; i++) {
			for (int j = 0; j < sz(chain[i]) * 4; j++) {
				node[i].push_back(0);
			}
			build(1, 1, sz(chain[i]), i);
		}
	}

	void update(int u, int val) {
		int x = pos[u], c = idx[u];
		update(1, 1, sz(chain[c]), x, val, c);
	}

	int hld_query(int u, int v) {
		int l = lca_query(u, v), ans = 0;
		while (1) {
			int c = idx[u];
			if (idx[u] == idx[l]) {
				ans += query(1, 1, sz(chain[c]), pos[l], pos[u], c);
				break;
			}
			ans += query(1, 1, sz(chain[c]), 1, pos[u], c);
			u = par[0][chain[c][0]];
		}
		while (1) {
			int c = idx[v];
			if (idx[v] == idx[l]) {
				ans += query(1, 1, sz(chain[c]), pos[l] + 1, pos[v], c);
				break;
			}
			ans += query(1, 1, sz(chain[c]), 1, pos[v], c);
			v = par[0][chain[c][0]];
		}
		return ans;
	}
};

int solve() {
	int n = in();
	for (int i = 1; i <= n; i++) {
		a[i] = in();
	}
	Heavy_light_Decompose_Seg_Tree graph;
	for (int i = 1; i < n; i++) {
		int u = in(), v = in();
		graph.add_edge(u, v);
	}
	graph.lca_build(1);
	graph.hld_build(1);
	graph.hld_process();
	int q = in();
	while (q--) {
		int ck = in();
		if (!ck) {
			int u = in(), val = in();
			graph.update(u, val);
		} else {
			int u = in(), v = in();
			printf("%d\n", graph.hld_query(u, v));
		}
	}
	return 0;
}

// DSU on Tree or Sack (HLD Style)

int col[N];

struct Sack_on_tree {

	std::vector<vi> g;
	std::vector<int> cnt, sz, ans;
	std::vector<bool> big;
	std::vector<vii> query;

	Sack_on_tree() {
		g.resize(N);
		cnt.resize(N, 0);
		sz.resize(N, 0);
		ans.resize(N, 0);
		big.resize(N, false);
		query.resize(N);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void add_qry(int u, int id, int c) {
		query[u].push_back({id, c});
	}

	void getsz(int u, int p = -1) {
		sz[u] = 1;
		for (auto v : g[u]) {
			if (v != p) getsz(v, u), sz[u] += sz[v];
		}
	}

	void add(int u, int p, int x) {
		cnt[col[u]] += x;
		for (auto v : g[u]) {
			if (v != p && !big[v]) add(v, u, x);
		}
	}

	void dfs(int u, int p, bool keep) { 
		int mx = -1, bigchild = -1;
		for (auto v : g[u]) {
			if (v != p && sz[v] > mx) mx = sz[v], bigchild = v;
		}
		for (auto v : g[u]) {
			if (v != p && v != bigchild) dfs(v, u, false);
		}
		if (bigchild != -1) dfs(bigchild, u, true), big[bigchild] = true;
		add(u, p, 1);
		for (auto x : query[u]) {
			ans[x.ff] = cnt[x.ss];
		}
		if (bigchild != -1) big[bigchild] = false;
		if (!keep) add(u, p, -1);
	}
};

int solve() {
	int n = in();
	for (int i = 1; i <= n; i++) {
		col[i] = in();
	}
	Sack_on_tree graph;
	for (int i = 1; i < n; i++) {
		int u = in(), v = in();
		graph.add_edge(u, v);
	}
	int q = in();
	for (int i = 1; i <= q; i++) {
		int u = in(), c = in();
		graph.add_qry(u, i, c);
	}
	graph.getsz(1);
	graph.dfs(1, -1, false);
	for (int i = 1; i <= q; i++) {
		printf("%d\n", graph.ans[i]);
	}
	return 0;
}

// Dynamic Diameter of tree

struct Node {
    ll d, a, b, c, ab, bc, abc;
    Node(ll d = 0, ll a = 0, ll b = 0, ll c = 0, ll ab = 0, ll bc = 0, ll abc = 0) :
        d(d), a(a), b(b), c(c), ab(ab), bc(bc), abc(abc) {}
    Node shift(ll del) {
        return Node(d + del, a + del, b - 2 * del, c + del, ab - del, bc - del, abc);
    }
} t[N << 3];

int n, m, q, in[N], out[N], l[N], r[N], idx;
vector<int> adj[N];
ll w[N], W;

Node merge(Node L, Node R) {
    R = R.shift(L.d);

    Node ret;
    ret.d = R.d;
    ret.a = max(L.a, R.a);
    ret.b = max(L.b, R.b);
    ret.c = max(L.c, R.c);
    ret.ab = max({L.ab, R.ab, L.a + R.b});
    ret.bc = max({L.bc, R.bc, L.b + R.c});
    ret.abc = max({L.abc, R.abc, L.ab + R.c, L.a + R.bc});

    return ret;
}

void update(int node, int l, int r, int i, ll x) {
    if (l == r) {
        t[node] = Node(x, x, -2 * x, x, -x, -x, 0);
    } else {
        int m = l + r >> 1;
        if (i <= m) update(node << 1, l, m, i, x);
        else update(node << 1 | 1, m + 1, r, i, x);
        t[node] = merge(t[node << 1], t[node << 1 | 1]);
    }
}

void dfs(int u, int p) {
    for (int i : adj[u]) {
        int v = l[i] ^ r[i] ^ u;
        if (v == p) continue;
        update(1, 1, m, ++idx, w[i]);
        in[i] = idx;
        dfs(v, u);
        update(1, 1, m, ++idx, -w[i]);
        out[i] = idx;
    }
}

int solve() {
    scanf("%d %d %lld", &n, &q, &W);
    for (int i = 0; i < n - 1; ++i) {
        scanf("%d %d %lld", &l[i], &r[i], &w[i]);
        adj[l[i]].push_back(i);
        adj[r[i]].push_back(i);
    }

    m = 2 * (n - 1);
    dfs(1, 0);

    ll last = 0;

    while (q--) {
        int i; ll e;
        scanf("%d %lld", &i, &e);
        i = (i + last) % (n - 1);
        e = (e + last) % W;

        update(1, 1, m, in[i], e);
        update(1, 1, m, out[i], -e);

        printf("%lld\n", last = t[1].abc);
    }
    return 0;
}

// Euler Tour (Tree Flood)

struct Euler_tour {

	int t;
	std::vector<vi> g, par;
	std::vector<int> st, et, dep;
	std::vector<ll> node;

	Euler_tour() {
		t = 0;
		g.resize(N);
		par.resize(18, vi(N, 1));
		st.resize(N, 0);
		et.resize(N, 0);
		dep.resize(N, 0);
		node.resize(4 * N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void propagate(int pos) {
		node[pos * 2] += node[pos];
		node[pos * 2 + 1] += node[pos];
		node[pos] = 0;
	}

	void update(int pos, int left, int right, int x, int y, int val) {
		if (left > y || right < x) return;
		if (left >= x && right <= y) {
			node[pos] += val;
			return;
		}
		if (node[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		update(pos * 2, left, mid, x, y, val);
		update(pos * 2 + 1, mid + 1, right, x, y, val);
	}

	int query(int pos, int left, int right, int x) {
		if (left > x || right < x) return 0;
		if (left == right) return node[pos];
		if (node[pos]) propagate(pos);
		int mid = (left + right) >> 1;
		int m = query(pos * 2, left, mid, x);
		int n = query(pos * 2 + 1, mid + 1, right, x);
		return m + n;
	}

	void dfs(int u, int p = -1, int d = 0) {
		st[u] = ++t;
		dep[u] = d;
		for (int i = 1; i <= 17; i++) {
			par[i][u] = par[i - 1][par[i - 1][u]];
		}
		for (int v : g[u]) {
			if (p == v) continue;
			par[0][v] = u;
			dfs(v, u, d + 1);
		}
		et[u] = t;
	}

	int lca(int u, int v) {
		if (dep[u] < dep[v]) swap(u, v);
		for (int i = 17; i >= 0 && u != v; i--) {
			if (dep[par[i][u]] >= dep[v]) u = par[i][u];
		}
		if (u == v) return u;
		for (int i = 17; i >= 0; i--) {
			if (par[i][u] != par[i][v]) u = par[i][u], v = par[i][v];
		}
		return par[0][u];
	}

	ll get_result(int u, int v, int n) {
		int l = lca(u, v);
		ll ans = 0;
		ans += query(1, 1, n, st[u]);
		ans += query(1, 1, n, st[v]);
		ans -= 2 * query(1, 1, n, st[l]);
		return ans + a[l];
	}
};

int solve() {
	int n = in(), q = in();
	for (int i = 1; i <= n; i++) {
		a[i] = in();
	}
	Euler_tour graph;
	for (int i = 1; i < n; i++) {
		int u = in(), v = in();
		graph.add_edge(u, v);
	}
	graph.dfs(n, 1, 1);
	for (int i = 1; i <= n; i++) {
		graph.update(1, 1, n, graph.st[i], graph.et[i], a[i]);
	}
	while (q--) {
		int ck = in();
		if (ck) {
			int u = in(), v = in();
			printf("%lld\n", graph.get_result(u, v, n));
		}
		else {
			int u = in(), val = in();
			a[u] += val;
			graph.update(1, 1, n, graph.st[u], graph.et[u], val);
		}
	}
	return 0;
}

// Kuhn Algo(maximum bipartite matching)

struct Kuhn_Algo {

	int t;
	std::vector<vi> g;
	std::vector<int> num, p, vis;

	Kuhn_Algo() {
		t = 1;
		g.resize(N);
		num.resize(N, 0);
		p.resize(N, 0);
		vis.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	bool kuhn(int u) {
		if (vis[u] == t) return false;
		vis[u] = t;
		for (auto v : g[u]) {
			if (p[v] == 0 || kuhn(p[v])) {
				p[v] = u;
				return true;
			}
		}
		return false;
	}

	int get_result(int n) {
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			if (kuhn(i)) ans++, t++;
		}
		return ans;
	}
};

// Max Flow Algorithm (Ford - Fulkarson)

struct Max_Flow_Ford_Fulkerson {

	std::vector<vi> g, cf;
	std::vector<int> par;
	std::vector<bool> vis;

	Max_Flow_Ford_Fulkerson() {
		g.resize(N);
		cf.resize(N, vi(N, 0));
		par.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v, int w) {
		g[u].push_back(v);
		g[v].push_back(u);
		cf[u][v] = w;
	}

	bool bfs(int n, int s, int sink) {
		for (int i = 1; i <= n; i++) {
			vis[i] = false, par[i] = 0;
		}
		queue<int>q;
		q.push(s);
		vis[s] = true;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			if (u == sink) return true;
			for (int i = 0; i < g[u].size(); i++) {
				int v = g[u][i];
				if (!vis[v] && cf[u][v] > 0) {
					vis[v] = true;
					par[v] = u;
					q.push(v);
				}
			}
		}
		return false;
	}

	ll maxflow(int n, int s, int sink) {
		ll flow = 0;
		while (bfs(n, s, sink)) {
			int cap = INT_MAX;
			int v = sink;
			while (par[v]) {
				int u = par[v];
				cap = min(cap, cf[u][v]);
				v = u;
			}
			v = sink;
			while (par[v]) {
				int u = par[v];
				cf[u][v] -= cap;
				cf[v][u] += cap;
				v = u;
			}
			flow += (ll)cap;
		}
		return flow;
	}
};

int solve() {
	int n = in(), m = in();
	Max_Flow_Ford_Fulkerson graph;
	for (int i = 1; i <= m; i++) {
		int u = in(), v = in(), w = in();
		graph.add_edge(u, v, w);
	}
	int s = in(), sink = in();
	printf("%lld\n", graph.maxflow(n, s, sink));
	return 0;
}

// Max Flow Algorithm (Dinic)

int n, m, s, t;

struct Max_Flow_Dinic {

	std::vector<vi> g;
	std::vector<vl> cf;
	std::vector<int> dis, idx;
	std::vector<bool> vis;

	Max_Flow_Dinic() {
		g.resize(N);
		cf.resize(N, vl(N, 0));
		dis.resize(N, -1);
		idx.resize(N, 0);
		vis.resize(N, false);
	}

	void add_edge(int u, int v, ll w) {
		g[u].push_back(v);
		g[v].push_back(u);
		cf[u][v] = w;
	}

	bool bfs() {
		queue<int>q;
		q.push(s);
		dis.resize(N, -1);
		dis[s] = 0;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			for (auto v : g[u]) {
				if (dis[v] == -1 && cf[u][v] > 0) {
					dis[v] = dis[u] + 1;
					q.push(v);
				}
			}
		}
		return (dis[t] != -1);
	}

	ll dfs(int u, ll cap) {
		if (cap == 0) return 0;
		if (u == t) return cap;
		for (int& i = idx[u]; i < g[u].size(); i++) {
			int v = g[u][i];
			if (dis[u] + 1 != dis[v] || cf[u][v] < 1) continue;
			ll flow = dfs(v, min(cap, cf[u][v]));
			if (flow == 0) continue;
			cf[u][v] -= flow;
			cf[v][u] += flow;
			return flow;
		}
		return 0;
	}

	ll maximum_flow() {
		ll flow = 0;
		while (1) {
			if (!bfs()) break;
			idx.resize(N, 0);
			while (ll cap = dfs(s, inf)) {
				flow += cap;
			}
		}
		return flow;
	}
};

int solve() {
	n = in(), m = in();
	Max_Flow_Dinic graph;
	for (int i = 1; i <= m; i++) {
		int u = in(), v = in();
		ll w = Lin();
		graph.add_edge(u, v, w);
	}
	s = in(), t = in();
	printf("%lld\n", graph.maximum_flow());
	return 0;
}

// Disjoint Set Union (DSU)

struct Disjoint_Set_Union {

	std::vector<int> par, Rank;

	Disjoint_Set_Union() {
		Rank.resize(N, 1);
		par.resize(N);
		for (int i = 1; i < N; i++) {
			par[i] = i;
		}
	}

	int Find(int u) {
		return par[u] == u ? u : par[u] = Find(par[u]);
	}

	void Union(int u, int v) {
		int x = Find(u), y = Find(v);
		if (Rank[x] < Rank[y]) swap(x, y);
		if (x != y) par[y] = x, Rank[x] += Rank[y];
	}
};

// Disjoint Set Union (Color in a range with color c) 

std::vector<pair<pii, int>> qry;
int color[N];

struct Disjoint_Set_Union {

	std::vector<int> par, Rank;

	Disjoint_Set_Union() {
		Rank.resize(N, 1);
		par.resize(N);
		for (int i = 1; i < N; i++) {
			par[i] = i;
		}
	}

	int Find(int u) {
		return par[u] == u ? u : par[u] = Find(par[u]);
	}

	void process_query(int l, int r, int c) {
		for (int u = l; ; ) {
			u = Find(u);
			if (u > r) break;
			color[u] = c;
			par[u] = u + 1;
		}
	}

	void process(int q) {
		for (int i = q - 1; i >= 0; i--) {
			process_query(qry[i].ff.ff, qry[i].ff.ss, qry[i].ss);
		}
	}
};

int solve() {
	int n = in(), q = in();
	for (int i = 0; i < q; i++) {
		int l = in(), r = in(), c = in();
		qry.push_back({{l, r}, c});
	}
	Disjoint_Set_Union dsu;
	dsu.process(q);
	for (int i = 1; i <= n; i++) {
		if (i > 1) printf(" ");
		printf("%d", color[i]);
	}
	printf("\n");
	return 0;
}

// Disjoint Set Union(Distance from Root)

struct Disjoint_Set_Union {

	std::vector<pii> par;
	std::vector<int> Rank;

	Disjoint_Set_Union() {
		Rank.resize(N, 1);
		par.resize(N);
		for (int i = 1; i < N; i++) {
			par[i] = {i, 0};
		}
	}

	pii Find(int u) {
		if (u != par[u].first) {
			int len = par[u].second;
			par[u] = Find(par[u].first);
			par[u].second += len;
		}
		return par[u];
	}

	void Union(int u, int v) {
		int x = Find(u).first, y = Find(v).first;
		if (Rank[x] < Rank[y]) swap(x, y);
		if (x != y) par[y] = {x, 1}, Rank[x] += Rank[y];
	}
};

int solve() {
	int n = in(), q = in();
	Disjoint_Set_Union dsu;
	while (q--) {
		int ck = in();
		if (ck == 1) {
			int u = in(), v = in();
			dsu.Union(u, v);
		}
		else {
			int u = in();
			pii ans = dsu.Find(u);
			printf("%d %d\n", ans.ff, ans.ss);
		}
	}
	return 0;
}

// Disjoint Set Union (Bipartite check)

struct Disjoint_Set_Union {

	std::vector<pii> par;
	std::vector<int> Rank;
	std::vector<int> bipartite;

	Disjoint_Set_Union() {
		Rank.resize(N, 1);
		par.resize(N);
		bipartite.resize(N, 1);
		for (int i = 1; i < N; i++) {
			par[i] = {i, 0};
		}
	}

	pii Find(int u) {
		if (u != par[u].first) {
			int parity = par[u].second;
			par[u] = Find(par[u].first);
			par[u].second ^= parity;
		}
		return par[u];
	}

	void add_edge(int u, int v) {
		pii x = Find(u);
		pii y = Find(v);
		u = x.first, v = y.first;
		int a = x.second, b = y.second;
		if (u == v) {
			if (a == b) bipartite[u] = 0;
		}
		else {
			if (Rank[u] < Rank[v]) swap(u, v);
			par[v] = {u, a ^ b ^ 1};
			bipartite[u] &= bipartite[v];
		}
	}

	bool is_partite(int u) {
		return bipartite[Find(u).first];
	}
};

int solve() {
	int n = in(), q = in();
	Disjoint_Set_Union dsu;
	while (q--) {
		int ck = in();
		if (ck == 1) {
			int u = in(), v = in();
			dsu.add_edge(u, v);
		}
		else {
			int u = in();
			if (dsu.is_partite(u)) printf("Bipartite\n");
			else printf("Not Bipartite\n");
		}
	}
	return 0;
}

// Minimum Vertex Cover (DP)

struct Minimum_Vertex_Cover {

	std::vector<vi> g, dp;
	std::vector<int> par;

	Minimum_Vertex_Cover() {
		g.resize(N);
		dp.resize(N, vi(2, -1));
		par.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	int mvc(int u, int state) {
		if (!g[u].size()) return 0;
		if (dp[u][state] != -1) return dp[u][state];
		int sum = 0;
		for (int i = 0; i < g[u].size(); i++) {
			int v = g[u][i];
			if (v != par[u]) {
				par[v] = u;
				if (!state) sum += mvc(v, 1);
				else sum += min(mvc(v, 0), mvc(v, 1));
			}
		}
		return dp[u][state] = sum + state;
	}
};

int solve() {
	int n = in();
	Minimum_Vertex_Cover graph;
	for (int i = 1; i < n; i++) {
		int u = in(), v = in();
		graph.add_edge(u, v);
	}
	printf("%d\n", min(graph.mvc(1, 0), graph.mvc(1, 1)));
	return 0;
}

// Bottom Up and Top Down Approach in Tree(DP)

vi g[N];
 
ll dp[N], s[N], ans;
 
void get_size(int u, int p = -1) {
	s[u] = 1;
	for (auto v : g[u]) {
		if (p == v) continue;
		get_size(v, u);
		s[u] += s[v];
	}
}
 
void get_dp(int u, int p = -1) {
	dp[u] = s[u];
	for (auto v : g[u]) {
		if (p == v) continue;
		get_dp(v, u);
		dp[u] += dp[v];
	}
}
 
void dfs(int u, int p = -1) {
	smax(ans, dp[u]);
	for (auto v : g[u]) {
		if (p == v) continue;
 
		dp[u] -= (dp[v] + s[v]);
		s[u] -= s[v];
		dp[v] += (dp[u] + s[u]);
		s[v] += s[u];
 
		dfs(v, u);
 
		dp[v] -= (dp[u] + s[u]);
		s[v] -= s[u];
		dp[u] += (dp[v] + s[v]);
		s[u] += s[v];
	}
}
 
int solve() {
	int n = in();
	for (int i = 0; i < n - 1; i++) {
		int u = in(), v = in();
		g[u].push_back(v);
		g[v].push_back(u);
	}
	get_size(1);
	get_dp(1);
	dfs(1);
	printf("%lld\n", ans);
	return 0;
}

// Maximum Value Without Adjacent Node in tree

ll val[N];

struct DP_on_Tree {

	std::vector<vi> g;
	std::vector<ll> dp1, dp2;

	DP_on_Tree() {
		g.resize(N);
		dp1.resize(N, 0);
		dp2.resize(N, 0);
	}

	void add_edge(int u, int v) {
		g[u].push_back(v);
		g[v].push_back(u);
	}

	void dfs(int u, int p = -1) {
		ll sum1 = 0LL, sum2 = 0LL;
		for (auto v : g[u]) {
			if (v == p) continue;
			dfs(v, u);
			sum1 += dp2[v];
			sum2 += max(dp1[v], dp2[v]);
		}
		dp1[u] = val[u] + sum1;
		dp2[u] = sum2;
	}
};

int solve() {
	int n = in();
	for (int i = 1; i <= n; i++) {
		val[i] = Lin();
	}
	DP_on_Tree graph;
	for (int i = 1; i < n; i++) {
		int u = in(), v = in();
		graph.add_edge(u, v);
	}
	graph.dfs(1);
	printf("%lld\n", max(graph.dp1[1], graph.dp2[1]));
	return 0;
}